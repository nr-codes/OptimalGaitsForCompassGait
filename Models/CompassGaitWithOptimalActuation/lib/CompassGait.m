(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`CompassGait`", {"GlobalVariables`", "RigidBodyDynamics`", "HybridDynamics`", "BipedalLocomotion`", "BipedalLocomotion`Model`", "Options`"}]

CompassGait::usage = "";
CompassGaitUnits::usage = "";

Begin["`Private`"]


(* ::Input::Initialization:: *)
name = "CG_";

(* parameters *)
mH = 10;
m = 5;
b = 0.5;
a = 0.5;
L = a + b;
g = 9.81;

(* scaling factors *)
mscale = 2 m + mH;
Lscale = a + b;
tscale = Sqrt[Lscale/g];
fscale = mscale Lscale / tscale^2;

(* reuse variables, but treat them as non-dimensionalize counterparts *)
mH = mH / mscale;
m = m / mscale;
b = b / Lscale;
a = a / Lscale;
L = L / Lscale;
g = g / (Lscale / tscale^2);

(*\[Mu] = 2; (* mH / m *)
\[Beta] = 1; (* b / a *)
L = 1+\[Beta];
a = 1/2;
g = {0, 9.81, 0}/a;*)

(* points of interest *)
foot = {0, -L, 0};
left = {"left leg", foot};
right = {"right leg", foot};


(* ::Input::Initialization:: *)
cT[c_] := Module[{cT},
cT = c;
cT[[u2i]] = -cT[[u2i]];
cT
];

cm[s_, A_] := Module[{q, v, a, n, \[Theta]0T, C},
(* BLc indices *)
n = mm -1; (* 2D *)
{q, v} = Partition[BLIndices[BLGetBipedBase[], "p", "n" -> {\[DoubleStruckQ], \[DoubleStruckV]}], n];
q = "q" -> {q, Range@Length@q, 2A["np", s]};
v = "v" -> {v, Range@Length@v, A["np", s]};

(* polynomial scaling factors *)
\[Theta]0T = 0A["\[Theta]", s];

(* function specific parameters *)
a = <|"BLc" -> <|q, v|>, "BLc0T" -> <|"\[Theta]" -> \[Theta]0T|>|>;

(* create parameters *)
C = BLContinuationParameters[Association -> a, "\[Mu]" -> \[Mu]i, "c[T]" -> cT];

<|s -> C|>
];

viz[] := Module[{r},
r = {4, 5, 6};
BLDontDraw[{"left leg"}];
BLRadius[0.09];
BLWidth[0.06];

<|
"axes" -> {1, 2},

"scale" -> L,

"poi" -> <|"left foot" -> \[DoubleStruckB]["left leg", r, foot], "right foot" -> \[DoubleStruckB]["right leg", r, foot]|>,

"lc" -> <|"right foot" -> LightGray|>
|>
];

CreateModel[] := Module[{com, c},
RBDNewModel[];
RBDLink["\[Theta]", Root, "m" -> 1, "S"-> "pz"];
RBDLink["left leg", Root, "m" -> mH, "S"-> "pln"];

com = {0, -b, 0};
c = {"left leg-1", "right leg"};
RBDLink[c, "left leg", "m" -> m, "com" -> com, "S"-> "rz"];
RBDLink["left leg-1", Merge];
RBDCreateModel["g" -> {0, 1, 0}g];
];


(* ::Input::Initialization:: *)
addToBLbiped[d_] := Module[{v, f, r},
(* replace built-in slope function so equilibria have correct derivative *)
f = BipedalLocomotion`Model`Private`AlternateCompile[##, "n" -> d]&;
r = BLAlternateCompile[Return, ##, "n" -> d]&;

v = With[{A = f[Compile, f[D, {0, 0, #1[[4]]+0.5#1[[5]]}&]]}, r["\[Sigma]", A]];
Do[BLbiped["\[Sigma]", k] = v;, {k, Keys@BLbiped["m"]}];

(* add impulse cost *)
v = With[{A = f[Compile, f[D, {#2[[ii]] . #2[[ii]]}&]]}, r["\[Iota]^2", A]];
BLbiped["\[Iota]^2"] = <||>;
Do[BLbiped["\[Iota]^2", k] = v;, {k, Keys@BLbiped["m"]}];

BLbiped
];


(* ::Input::Initialization:: *)
CompassGaitUnits::arg = "Unknown type: ``.  Returning var unchanged.";
CompassGaitUnits[var_, type_:"c", tounits_:False] := Module[{q, f, scale},
q = {tscale, Lscale, Lscale, 1, 1};
f = {1, Lscale} mscale Lscale / tscale^2; (* N, Nm *)
Switch[type,
"x", 
scale = Join[q, q/tscale];,
"c",  
scale = If[Length@var == ncp, {1, q[[2]]/tscale}, {}];
scale = Join[q[[4;;5]], q[[4;;5]]/tscale, scale];
scale = Join[scale, ConstantArray[f[[2]], nru]];
scale = Join[scale, ConstantArray[tscale, nrt]];,
"u",  
scale = ArrayPad[f, {2, 1}, "Fixed"];,
_, 
Message[CompassGaitUnits::arg, type]; 
scale = 1;
];

If[tounits, scale, 1/scale] var
]


(* ::Input::Initialization:: *)
CompassGaitAlternateCompile[opts:OptionsPattern[BLAlternateCompileBiped]] := Module[{o, f, r, v, k},
Block[{\[DoubleStruckU], ufun},
(* compile biped *)
o = MergeOpts[BLAlternateCompile -> "v" -> {{\[DoubleStruckX], nx}, {\[DoubleStruckC], nc}, {\[DoubleStruckU], nq}}, {opts}];
ufun = Array[\[DoubleStruckU], nq]&;
BLAlternateCompileBiped[o];

(* compile u *)
o = OptionValue@BLAlternateCompile;
f = BipedalLocomotion`Model`Private`AlternateCompile[##, o]&;
r = BLAlternateCompile[Return, ##, o]&;
BLbiped["u"] = <||>;
Do[
ufun = cip["u", m];
BLbiped["u", m] = With[{A = f["u"]}, r["u", A]];,
{m, Keys@BLbiped["m"]}
];
];

(* get compiled functions from con and update BLbiped *)
k = #["name"]& /@ BipedalLocomotion`Model`Private`GetCompilableFunctions[];
Do[
With[{a = BLbiped[i, j], b = BLbiped["u", j]}, 
BLbiped[i, j] = a[##, devec[b[##], nq]]&;
];,
{i, k}, {j, Keys@BLbiped["u"]}
];

k = OptionValue[BipedalLocomotion`Model`Private`AlternateCompile, o, "n"];
\[CurlyPhi][BLbiped, k];

BLbiped
];


(* ::Input::Initialization:: *)
Options[CompassGait] = {"a" -> {}, "e" -> {}, "i" -> False, "d" -> 2};

CompassGait[opts:OptionsPattern[]] := Module[{A, C, X, J, F, L, R, d},
d = OptionValue["d"];

CreateModel[];

(* updates params, name, and ufun *)
updateParams[opts];

(* coordinate flip *)
BLA[];
A = IdentityMatrix[nq];
A[[4, 5]] = 1;
A[[5, 5]] = -1;
A = ArrayFlatten[{{A, 0}, {0, A}}];

(* feet constraints *)
F = {left, right};

(* create dynamic regimes *)
L = BLRegime["left", "P" -> <|0 -> {left}|>, "S" -> F, "n\[Mu]" -> n\[Mu]];
R = BLRegime["right", "P" -> <|0 -> {right}|>, "S" -> Reverse@F, "n\[Mu]" -> n\[Mu]];
C = Join[L, R];

(* add constraints for impulse *)
RBDTranV["right-i", \[DoubleStruckB]'["left leg",{4, 5},foot]];
RBDTranV["left-i", \[DoubleStruckB]'["right leg",{4, 5},foot]];

(* create jumps given state of biped at transition at t- (pre-impact) *)
L = BLxT["left", "ST" -> right, "SW" -> left, "A" -> A];
R = BLxT["right", "ST" -> left, "SW" -> right, "A" -> A];
X = Join[L, R];

(* create state-time-control space parameters *)
J = <|"A" -> A, "controls" -> cip|>;
A = BLCreateBiped[name, C, X, viz[], F, J];

C = Join[cm["left", A], cm["right", A]];
BLCreateContinuationParameters["right", C];

(* add # of derivatives to get single arg vec[...] working *)
\[CurlyPhi]["nd"];
(* compile biped down to C-ish code *)
CompassGaitAlternateCompile[BLAlternateCompile -> "n" -> d];

(* add extra integral equations *)
(* we need to pass total number of functions b/c devec switches from nd = 1 to nd = default *)
(* keep in mind that a[t] has length = to # of bounds *)
BLApplyBoundsAux["cost", {3 -> {-\[Infinity], -\[Infinity]}}, "n" -> 4];

addToBLbiped[d]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
