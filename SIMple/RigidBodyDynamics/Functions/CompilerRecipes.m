(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
PackageVariables.nb: Lists global variables used by the NLinks package.
Copyright (C) 2014 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["RigidBodyDynamics`", {"GlobalVariables`", "Derivatives`"}]
Begin["`Private`"]


(* ::Input::Initialization:: *)
RBDMergeRecipes[x__] := Module[{f, a, r, X},
f = If[Length@# <= 1, #[[1]], Join@@#]&;
r = Hold[a_] :> With[{e = f[a]}, e /; True];
X = Flatten@{x} /. {"confun" -> confun, "spatfun" -> spatfun, "FMbJ" -> FMbJ, "HMbJ" -> HMbJ, "\[Eta]MbJ" -> \[Eta]MbJ, "datrules" -> datrules};

With[{A = X},
BlockExpression[{}, 
Merge[A, Hold] /. r, 
{f, r, True}
]
]
];

RBDGetRecipe::n = "`` is an unknown recipe.";
RBDGetRecipe[name_] := Switch[name, 
"FMbJ", RBDMergeRecipes["FMbJ", <|"f" :> {F}|>],
"HMbJ", RBDMergeRecipes["HMbJ", <|"f" :> {H}|>],
"\[Eta]MbJ", RBDMergeRecipes["\[Eta]MbJ", <|"f" :> {Eta}|>],
True, Message[RBDGetRecipe::n, name]; <||>
];


(* ::Input::Initialization:: *)
spatfun = <|
"I" :> {
{ufun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{agfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{sfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{sdotfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{fext0fun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{\[DoubleStruckCapitalI]fun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{XLfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{z1,{{\[DoubleStruckX], _Real, nx}}}, 
{z3,{{\[DoubleStruckX], _Real, nx}}}, 
{z6, {{\[DoubleStruckX], _Real, nx}}}, 
{zq, {{\[DoubleStruckX], _Real, nx}}}, 
{zspat, {{\[DoubleStruckX], _Real, nx}}}, 
{Z3, {{\[DoubleStruckX], _Real, nx}}}, 
{ZM, {{\[DoubleStruckX], _Real, nx}}}
},

"O" :> {}
|>;

confun = <|
"I" :> {
{\[Phi]fun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{rfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{rdotfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{Jfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{Tcbfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}}, 
{\[Eta]fun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{Kfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}},
{zpos, {{\[DoubleStruckX], _Real, nx}}},
{ZAb, {{\[DoubleStruckX], _Real, nx}}}
},

"O" :> {}
|>;

datrules = {HoldPattern[parent] :>  parent, HoldPattern[bx] :>  rb[C, "bx"], HoldPattern[bs] :> rb[C, "bs"], HoldPattern[bo] :>  rb[C, "bo"], HoldPattern[ba] :> rb[C, "ba"], HoldPattern[pcons] :>  rb[C, "p"], HoldPattern[vcons] :>  rb[C, "v"], HoldPattern[ucons] :>  rb[C, "u"]};


(* ::Input::Initialization:: *)
FMbJ = <|
"name" -> "f",

"f" :> {MbJQtys, RNEA, CRB, X0, rs0, JOSIM, EOM},

"lcls" :> {q, qd, qdd, u, uJ, ag, fext0, \[Phi], s, sdot, v, a, f, fext, r, rdot, sj, ro, sjdot, rodot, posXco, M, \[DoubleStruckCapitalI], XL, Tcb, XL0, X0L, RL0, R0L, sj, sjdot, ro, rodot, Xo0, J, \[Phi], \[Eta], K, Ab, b, o, nq, nx, nf, nv, nu},

"v" :> {{\[DoubleStruckX], _Real, 1}, {\[DoubleStruckC], _Real, 1}, {ufun, _Real, 1}, {agfun, _Real, 1}, {\[Phi]fun, _Real, 1}, {sfun, _Real, 2}, {sdotfun, _Real, 2}, {fext0fun, _Real, 2}, {rfun, _Real, 2}, {rdotfun, _Real, 2}, {Jfun, _Real, 2}, {\[Eta]fun, _Real, 2}, {Kfun, _Real, 3}, {\[DoubleStruckCapitalI]fun, _Real, 3}, {XLfun, _Real, 3}, {Tcbfun, _Real, 3}, {z1, _Real, 0}, {z3, _Real, 1}, {z6, _Real, 1}, {zq, _Real, 1}, {zpos, _Real, 1}, {zspat, _Real, 2}, {Z3, _Real, 2}, {ZM, _Real, 2}, {ZAb, _Real, 2}},

"d" :> {{parent, _Integer, 1}, {bx, _Integer, 1}, {bs, _Integer, 1}, {bo, _Integer, 2}, {ba, _Integer, 3}, {pcons, _Integer, 1}, {vcons, _Integer, 1}, {ucons, _Integer, 1}},

"I" :> {
{mxv, {{m, _Real, nm}, {v, _Real, nm}}},
{mxstarf, {{m, _Real, nm}, {v, _Real, nm}}},
{posX, {{X, _Real, {nm, nm}}, {Y, _Real, {nm, nm}}}},
{mxX, {{m, _Real, nm}, {X, _Real, {nm, nm}}}}
},

"O" :> {{mxv, _Real, 1}, {mxstarf, _Real, 1}, {posX, _Real, 1}, {mxX, _Real, 2}},

"C" :> {}
|>;


(* ::Input::Initialization:: *)
MbJQtys[] := Module[{},
ag = agfun;
s = sfun;
sdot = sdotfun;
XL = XLfun;
\[DoubleStruckCapitalI] = \[DoubleStruckCapitalI]fun;
u = ufun;
fext0 = fext0fun;

r = rfun;
rdot = rdotfun;
Tcb = Tcbfun;
J = Jfun;
\[Phi] = \[Phi]fun;
\[Eta] = \[Eta]fun;
K = Kfun;

nq = Length[u];
nx = 2nq;

nf = Length@pcons;
nv = Length@vcons;
nu = Length@ucons;

q = \[DoubleStruckX][[1;;nq]];
qd = \[DoubleStruckX][[nq+1;;nx]];
qdd = zq;
];


(* ::Input::Initialization:: *)
EOM[] := Module[{nqfv, nqfu, nqfub, pu, pv, fosim, xdot},
(* set up lengths of the different constraints *)
nqfv = nq + nf + nv;
nqfu = nq + nf + nu;
nqfub = nqfu + 1;

(* solves for qdd, f, u *)
Ab = ZAb;

(* formulate M.qdd + uJ = B.u + \[Tau] + J\[Transpose].f *)
Ab[[1;;nq, 1;;nq]] = M;
Ab[[1;;nq, nqfub]] = u-uJ;

If[nf >0 || nv > 0, 
pu = Join[pcons, ucons];
pv = Join[pcons, vcons];
Ab[[1;;nq, nq+1;;nqfu]] = -J[[pu]]\[Transpose];
Ab[[nq+1;;nqfv, 1;;nq]] = J[[pv]];
Ab[[nq+1;;nqfv, nqfub]] = -\[Phi][[pv]];
];
];

UpperTriangularizeAb[] := Module[{Jpv, JBb, MJBb, JMJBb, \[CapitalLambda]p, \[CapitalLambda]v, nub, nfv, nfub, nqf, nqfv, nqfu, nqfub, xdot, fosim},
If[(*nf > 0 && nv > 0*)nf > 0 || nv > 0,
nub = nu + 1;
nfv = nf + nv;
nfub = nf + nu + 1;
nqf = nq + nf;
nqfv = nq + nfv;
nqfu = nq + nf + nu;
nqfub = nqfu + 1;

(* extract and zero Jp and Jv *)
Jpv = Ab[[nq+1;;nqfv, 1;;nq]];
Ab[[nq+1;;nqfv, 1;;nq]] = ZAb[[nq+1;;nqfv, 1;;nq]];

(* solve for operational-space inertia matrices J.Inverse[M].[J\[Transpose]|B|b] *)
JBb = -Ab[[1;;nq, nq+1;;nqfub]];
MJBb = LinearSolve[M, JBb];
JMJBb = Jpv . MJBb;
JMJBb[[1;;nfv, nfub]] = Ab[[nq+1;;nqfv, nqfub]] + JMJBb[[1;;nfv, nfub]];
(* fills in physical equations *)
Ab[[nq+1;;nqf, nq+1;;nqfub]] = JMJBb[[1;;nf, 1;;nfub]];

If[nf > 0 && nv > 0,
(* fills in virtual constraint equations *)
\[CapitalLambda]p = LinearSolve[JMJBb[[1;;nf, 1;;nf]], JMJBb[[1;;nf, nf+1;;nfub]]];
\[CapitalLambda]v = JMJBb[[nf+1;;nfv, nf+1;;nfub]] - JMJBb[[nf+1;;nfv, 1;;nf]] . \[CapitalLambda]p;

Ab[[nqf+1;;nqfv, nqf+1;;nqfub]] = \[CapitalLambda]v[[1;;nv, 1;;nub]];
];
];
];

F[] := Module[{nqfv, nqfu, nqfub, fosim, xdot},
nqfv = nq + nf + nv;
nqfu = nq + nf + nu;
nqfub = nqfu + 1;

fosim = LinearSolve[Ab[[1;;nqfv, 1;;nqfu]], Ab[[1;;nqfv, nqfub]]];
qdd = fosim[[1;;nq]];
xdot = Join[qd, qdd];
Flatten[{xdot}]
];


(* ::Input::Initialization:: *)
HMbJ = Join[FMbJ, <|"name" -> "h", "f" :> {MbJQtys, V, CRB, X0, rs0, JOSIM, IME}|>];


(* ::Input::Initialization:: *)
IME[] := Module[{nqf, nqfb, fosim, xdot},
(* set up lengths of the different constraints *)
nqf = nq + nf;
nqfb = nqf + 1;

(* solves for qdd, f, u *)
Ab = ZAb;

(* formulate M.qdd + uJ = B.uff + u + J\[Transpose].f *)
Ab[[1;;nq, 1;;nq]] = M;
Ab[[1;;nq, nqfb]] = M . qd;

If[nf >0, 
Ab[[1;;nq, nq+1;;nqf]] = -J[[pcons]]\[Transpose];
Ab[[nq+1;;nqf, 1;;nq]] = J[[pcons]];
If[nv > 0 && nv == nf,
(* for implementing non-plastic collisions, could also add \[Phi]\[LeftDoubleBracket]vcons\[RightDoubleBracket] *)
Ab[[nq+1;;nqf, nqfb]] = -J[[vcons]] . qd;
];
];
];

H[] := Module[{nqf, nqfb, fosim, xpost},
(* set up lengths of the different constraints *)
nqf = nq + nf;
nqfb = nqf + 1;

fosim = LinearSolve[Ab[[1;;nqf, 1;;nqf]], Ab[[1;;nqf, nqfb]]];
xpost = Join[q, fosim[[1;;nq]]];
Flatten[{xpost}]
];


(* ::Input::Initialization:: *)
\[Eta]MbJ = <|
"name" -> "\[Eta]",

"f" :> {MbJQtys, V, X0, rs0, JOSIM},

"lcls" :> {q, qd, qdd, u, uJ, ag, fext0, \[Phi], s, sdot, v, a, f, fext, r, rdot, sj, ro, sjdot, rodot, posXco, M, \[DoubleStruckCapitalI], XL, Tcb, XL0, X0L, RL0, R0L, sj, sjdot, ro, rodot, Xo0, J, \[Phi], \[Eta], K, Ab, b, o, nq, nx, nf, nv, nu},

"v" :> {{\[DoubleStruckX], _Real, 1}, {\[DoubleStruckC], _Real, 1}, {ufun, _Real, 1}, {agfun, _Real, 1}, {\[Phi]fun, _Real, 1}, {sfun, _Real, 2}, {sdotfun, _Real, 2}, {fext0fun, _Real, 2}, {rfun, _Real, 2}, {rdotfun, _Real, 2}, {Jfun, _Real, 2}, {\[Eta]fun, _Real, 2}, {Kfun, _Real, 3}, {\[DoubleStruckCapitalI]fun, _Real, 3}, {XLfun, _Real, 3}, {Tcbfun, _Real, 3}, {z3, _Real, 1}, {z6, _Real, 1}, {zq, _Real, 1}, {zpos, _Real, 1}, {zspat, _Real, 2}, {Z3, _Real, 2}, {ZM, _Real, 2}, {ZAb, _Real, 2}},

"d" :> {{parent, _Integer, 1}, {bx, _Integer, 1}, {bs, _Integer, 1}, {bo, _Integer, 2}, {ba, _Integer, 3}, {pcons, _Integer, 1}, {vcons, _Integer, 1}, {ucons, _Integer, 1}},

"I" :> {
{mxv, {{m, _Real, nm}, {v, _Real, nm}}},
{mxstarf, {{m, _Real, nm}, {v, _Real, nm}}},
{posX, {{X, _Real, {nm, nm}}, {Y, _Real, {nm, nm}}}},
{mxX, {{m, _Real, nm}, {X, _Real, {nm, nm}}}}
},

"O" :> {{mxv, _Real, 1}, {mxstarf, _Real, 1}, {posX, _Real, 1}, {mxX, _Real, 2}},

"C" :> {}
|>;

Eta[] := Module[{},
Flatten[{\[Eta]}]
];


(* ::Input::Initialization:: *)
End[];
EndPackage[]
