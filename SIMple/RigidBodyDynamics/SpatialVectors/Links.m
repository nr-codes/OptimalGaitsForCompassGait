(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["RigidBodyDynamics`", "GlobalVariables`"]
Begin["`Private`"]

rb = <||>; (* description of the current rigid body system *)
info = {"p", "joint", "frame", "inertia"};

RBDindex = <|"n"  -> 1, "p"  -> 2, "S"  -> 3, "f"  -> Range[4,9],"f[x]"  -> 7, "f[y]"  -> 8, "f[z]"  -> 9,  "f[xyz]"  -> Range[7,9], "mcI"  ->  Range[10, 25], "m"  -> 10, "c"  -> Range[11, 16], "c[x]"  -> 14, "c[y]"  -> 15, "c[z]"  -> 16, "c[xyz]"  -> Range[14, 16], "I"  -> Range[17,25]
|>;


(* ::Input::Initialization:: *)
RBDNewModel[] := (rb = <||>; con = {};);


(* ::Input::Initialization:: *)
Options[RBDCreateModel] = {"L" -> {}, "C" -> {}, "cons" -> {}, "g" -> Automatic, "nc" -> Automatic, "\[Epsilon]" -> Automatic, "spat" -> True}

RBDCreateModel[OptionsPattern[]] :=Module[{L, C, cons},
L = OptionValue["L"];
C = OptionValue["C"];
cons = OptionValue["cons"];

If[OptionValue["g"] =!= Automatic, RBDGravity[OptionValue["g"]]];
If[OptionValue["nc"] =!= Automatic, RBDParameters[OptionValue["nc"]]];
If[OptionValue["\[Epsilon]"] =!= Automatic, RBDSetEpsilon[OptionValue["\[Epsilon]"]]];

If[L =!= {}, 
RBDLink[All, Remove];
RBDLinks[L];
];

If[OptionValue["spat"],
RBDSpatialFunctions[];,
GetExpandedTree[];
];

If[C =!= {},  
RBDRemoveConstraint[];
RBDAddConstraints[C];
];

If[cons === {},
RBDConstraintFunctions[],
RBDConstraintFunctions[cons]
];
];


(* ::Input::Initialization:: *)
RBDGravity[g_:{0, 9.81, 0}] := AssociateTo[rb, "g" -> ConvertToXLFunction@PadLeft[g, nm]]["g"];

RBDParameters[n_] := (nc = AssociateTo[rb, "nc" -> n]["nc"]);


(* ::Input::Initialization:: *)
joint = <||>; (* unit spatial velocity *)
joint["rx"] = I6[[1]]&;
joint["ry"] = I6[[2]]&;
joint["rz"] = I6[[3]]&;
joint["px"] = I6[[4]]&;
joint["py"] = I6[[5]]&;
joint["pz"] = I6[[6]]&;
joint["sph"] = {"rx", "ry", "rz"};
joint["fb"] = {"px", "py", "pz", "rx", "ry", "rz"};
joint["pln"] = {"px", "py", "rz"};
joint["xy"] = {"px", "py"};
joint["xyz"] = {"px", "py", "pz"};

XJ = <||>; (* joint coordinate transform *)
XJ["rx"] =  rotX[#]&;
XJ["ry"] =  rotY[#]&;
XJ["rz"] =  rotZ[#]&;
XJ["px"] =  transX[#]&;
XJ["py"] =  transY[#]&;
XJ["pz"] =  transZ[#]&;

RBDJoint[] := Keys@joint;

RBDJoint[s_String] := joint[s];

RBDJoint[type_String, s_, xj_:None] := (joint[type] = s; If[xj =!= None, XJ[type] = xj;]);


(* ::Input::Initialization:: *)
RBDGetLinkInfo[Keys] := info

RBDGetLinkInfo[k_, rbld_:False]:=Module[{t}, 
t = If[rbld, GetTree[], Lookup[rb, TreeForm, GetTree[]]];
If[Length@t == 0, t, rb[[Keys@t,k]]]
];

RBDGetLinkNames[rbld_:False] := Keys@If[rbld, GetTree[], Lookup[rb, TreeForm, GetTree[]]];



(* ::Input::Initialization:: *)
RBDGetDOF::args = "First argument (`1`) must be string and second argument (`2`) must either be a string, integer, Values (for all dof names), or Integers (for all dof indices).";

SetAttributes[RBDGetDOF, Listable];

RBDGetDOF[i_String] := Module[{b, k},
(* get combined link-dof names *)
k = Keys@rb[Links, TreeForm];
k = Select[k, StringContainsQ[#, i]&];
(* return dof names *)
If[k === {}, Message[RBDGetIndex::s, i, RBDGetLinkNames[]]];
StringDrop[k, StringLength@i+1]
];

RBDGetDOF[f_[i_, j_]] := Module[{k}, 
k = Which[
j === Values, RBDGetDOF@i, 
j === Integers, Range@Length@RBDGetDOF@i,
True, RBDGetDOF[i, j]
];

Thread@f[i, k]
];

RBDGetDOF[i_, j_] := Module[{},
Message[RBDGetDOF::args, i, j];
{}
]

RBDGetDOF[i_String, j_Integer] := Module[{k, n},
k = RBDGetDOF[i];
n = Length@k;
If[Abs[j] <= n && j != 0, k[[j]], Message[RBDGetIndex::n, i, j, n]; {}]
]

RBDGetDOF[i_String, j_String] := Module[{k, b},
b = RBDGetDOF[i];
k = Pick[Range@Length@b, StringContainsQ[b, j]];
If[k === {},  Message[RBDGetIndex::jnt, j, b]];

b = Length@k;
If[b == 1, k[[1]], k]
]


(* ::Input::Initialization:: *)
SetAttributes[RBDLink, Listable];

Options[RBDLink] = {"m"-> 1, "com"-> {0,0,0,0,0,0}, "I"-> {0,0,0}, "S"-> "rz", "loc"-> {0,0,0,0,0,0}};

RBDLinks[] := Module[{n, p, j, f, i},
n = Keys@GetTree[];
If[n === {}, Return[n]];
p = Values@RBDGetLinkInfo["p", False];
j = Values@RBDGetLinkInfo["joint", False];
f = Values@RBDGetLinkInfo["frame", False];
i = Values@RBDGetLinkInfo["inertia", False];
MapThread[Flatten@{##}&, {n, p, j, f, i}]
];


(* ::Input::Initialization:: *)
RBDLink[name_, parent_, OptionsPattern[]] := Module[{r},
r = OptionValue[{"m", "com", "I"}];
r[[2]] = PadLeft[r[[2]], nm];
If[Length@r[[3]] == mm, r[[3]] = DiagonalMatrix[r[[3]]];];

rb[name] = <|
 "p"-> parent,
"joint"-> OptionValue["S"],
"frame"-> PadLeft[OptionValue["loc"], nm], 
"inertia"-> Flatten@r
|>;

Flatten@Prepend[Values@rb[[name, info]], name]
];

RBDLinks[bodies_] := Module[{n, p, s, f, m, com, I, g},
n = bodies[[All, RBDindex["n"]]];
p = bodies[[All, RBDindex["p"]]];
s = bodies[[All, RBDindex["S"]]];
f = bodies[[All, RBDindex["f"]]];
m = bodies[[All, RBDindex["m"]]];
com = bodies[[All, RBDindex["c"]]];
I = bodies[[All, RBDindex["I"]]];

g = RBDLink[#1, #2, "S" -> #3, "loc" -> #4, "m" -> #5, "com" -> #6, "I" -> #7]&;

MapThread[g, {n, p, s, f, m, com, I}]
];


(* ::Input::Initialization:: *)
RBDLink[name_, Remove] := Module[{P, C},
P = RBDGetLinkInfo["p", True];
If[name === All, RBDLink[Keys@P, Remove]];
If[KeyFreeQ[P, name], Return[]];

(* reference children to parent link frame *)
C = Flatten@Position[P, name] /. Key -> Identity;
Do[
rb[c, "frame"] = rb[c, "frame"] + rb[name, "frame"];
rb[c, "p"] = rb[name, "p"];,
{c, C}
];

KeyDropFrom[rb, {name, ParentList, TreeForm, Links}];
];

RBDLink[name_, Merge] := Module[{p, I},
p = rb[name, "p"];
If[MissingQ[p], Return[]];

(* combine link and parent link inertias *)
If[p =!= Root,
(* place COM in parent's frame *)
I = rb[name, "inertia"];
I[[2;;7]] = I[[2;;7]] + rb[name, "frame"];
(* combine inertias *)
rb[p, "inertia"] = mcI@Itot[{rb[p, "inertia"], I}];
];

RBDLink[name, Remove];
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
