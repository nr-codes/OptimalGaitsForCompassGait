(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`", "GlobalVariables`"]
Begin["`Private`"]


(* ::Input::Initialization:: *)
SplineValidQ[c_?VectorQ, t_?VectorQ, p_] := SplineValidQ[Length@c - 1, Length@t - 1, p];

SplineValidQ[n_, m_, p_] := n >= 0 && m >= 0 && p >= 0 && m == n + p + 1;


(* ::Input::Initialization:: *)
SplineParameters["Bezier", v_] := Module[{n, t},
n = If[VectorQ[v], Length@v - 1, v]; (* = p *)
ArrayPad[{0, 1}, {n, n}, "Fixed"]
];

SplineParameters["Clamped", v_, p_, k_:True] := Module[{t},
t = If[k (* knot vector *), v, Subdivide[Length@v - p]];
ArrayPad[t, {p, p}, "Fixed"]
];

SplineParameters["NURBS", c_, w_] := If[VectorQ[c], Join[c w, w], Join[(w c)\[Transpose], {w}]\[Transpose]];

SplineParameters["Project", c_] := c[[1;;-2]]/c[[-1]];

SplineParameters["Uniform", c_, p_, t_:{0, 1}] := Module[{a, n, m},
n = If[IntegerQ[c], c, Length@c - 1];
m = n + p + 1;
n = n - p;
a = Table[i/(n+1), {i, -p, m - p}];
(1-a) t[[1]] + a t[[2]]
];

SplineParameters["Closed", c_, p_, t_:{0, 1}] := Module[{d},
d = Join[c, c[[1;;p]]];
{SplineParameters["Uniform", d, p, t], d}
];


(* ::Input::Initialization:: *)
KnotSpanQ[x_, t_?VectorQ, i_] :=KnotSpanQ[x, t[[i+1]], t[[i+2]]];
KnotSpanQ[x_, ts_, te_] := ts <= x < te;


(* ::Input::Initialization:: *)
KnotIndex[x_, t_, p_] := Module[{k, m, n},
m = Length@t - 1;
n = m - p - 1;
k = !SplineValidQ[n, m, p] || !KnotSpanQ[x, t[[p+1]], t[[n+2]]];
(* are there enough knot points and is x in range? *)
If[k, Throw@$Failed, Select[Range[p, n], KnotSpanQ[x, t, #]&][[-1]]]
];


(* ::Input::Initialization:: *)
Spline[x_, t_, c_, S_:DeBoor] := Module[{m, n, p, T, k},
m = Length@t - 1;
n = Length@c - 1;
p = m - n - 1;
k = Range[p, n];
T = DeleteDuplicates@t[[k + 1]];
If[VectorQ[T, NumericQ], k = KnotIndex[#, t, p]& /@ T];
Total[S[x, t, c, #, p]& /@ k]
];


(* ::Input::Initialization:: *)
DeBoor[x_, t_, c_, k_, p_] := Module[{i, d, te, ts, a, b},
i = k + 1;
d = c[[i-p;;i]];

Do[
ts = t[[j + i - p]];
te = t[[j + 1 + i - r]];
a = x - ts;
b = te - ts;
(* Piecewise doesn't compute val if ts \[GreaterEqual] te avoiding a/0 errors *)
d[[j + 1]] = PiecewiseExpand@Piecewise[{{(1 - a/b) d[[j]] + a/b d[[j+1]], ts <= x < te}}];,
{r, 1, p}, {j, p, r, -1}
];

ts = t[[i]];
te = t[[i + 1]];
PiecewiseExpand@Piecewise[{{d[[p + 1]], ts <= x < te}}]
];


(* ::Input::Initialization:: *)
B[x_, t_, i_, 0] := Piecewise[{{1, KnotSpanQ[x, t, i]}}];

B[x_, t_, i_, p_] := Module[{j, a, b, c, d, f, g},
j = i + 1;
{a, b, c, d} = t[[{j, j+p, j + 1, j+p+1}]];
f = Piecewise[{{(x - a)/(b - a) B[x, t, i, p - 1], a <= x < b}}];
g = Piecewise[{{(d - x)/(d - c) B[x, t, i + 1, p - 1], c <= x < d}}];
f + g
];


(* ::Input::Initialization:: *)
S[x_, t_, c_, k_, p_] := Piecewise[
{{Sum[c[[i+1]] B[x, t, i, p], {i, k - p, k}],  KnotSpanQ[x, t, k]}}
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
