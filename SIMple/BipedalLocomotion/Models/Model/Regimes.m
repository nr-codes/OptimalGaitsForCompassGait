(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`Model`", {"GlobalVariables`", "RigidBodyDynamics`", "BipedalLocomotion`"}]

Begin["`Private`"]


(* ::Input::Initialization:: *)
comcon[n_, v_, p_:True] := Module[{lnks, mtot, b, N},
RBDVirtQ[n, v, Expand -> False, "\[Phi]" -> p];

lnks = Rest@RBDLinks[];
mtot = Total@lnks[[All, 10]];
b = \[DoubleStruckB][#1[[1]], #1[[10]]/mtot I6[[#2]], #1[[14;;16]]]&;
Do[RBDVirtQ[n, b[i, j], "n" -> j+1, Expand -> False, "\[Phi]" -> p], {i, lnks}, {j, {4, 5}}]
];


(* ::Input::Initialization:: *)
rbdind = Function[x, If[IntegerQ@x, x, RBDGetIndex@x], Listable];

regime[name_, data_] := Module[{P, V, B, M, \[Theta], Pcon, n\[Mu]T, dt, J, n, m, so\[Theta], PT, Pd, Vd, S, I},
P = data["P"];
V = data["V"]; 
B = data["B"];
I = data["I"];
M = data["M"];
\[Theta] = data["\[Theta]"];
Pcon = data["Pcon"];
dt = data["dt"];
n\[Mu]T = data["n\[Mu]"] + Length@Select[DeleteDuplicates@dt, #!= 0&];
J = data["J[p]"];
S = data["S"];

(* stance foot constraints *)
RBDConQ[name <> "-p", P];
(* virtual constraints *)
RBDVirtQ[name <> "-v", V];
(* transmission matrix *)
RBDTranV[name <> "-u", B];
(* impacts *)
RBDConQ[name <> "-i", I];

(* trajectory to follow *)
n = \[Theta][[1]];
so\[Theta] = (n[[1;;2]] - {n[[3]], 0})/(n[[4]]-n[[3]]);
PT = PolynomialTrajectory[M, so\[Theta], "c" -> nx+1];

n = Length[P];
m = Length[M];
Pd = PT[["\[Eta]d", 1;;n]];
Vd = PT[["\[Eta]d", n+1;;m]];

(* add trajectories as constraints *)
RBDConQ[name <> "-b", -Pd, Thread["n" -> Range[n]]];
RBDVirtQ[name <> "-b", -Vd, Thread["n" -> Range[n+1, m]]];

(* \[Eta] constraints *)
(* w/ no coefficients, get (h0, h0dot) *)
RBDConQ[name <> "-\[Eta]0", P, "\[Phi]" -> False];
RBDVirtQ[name <> "-\[Eta]0", V, "\[Phi]" -> False];

RBDConQ[name <> "-\[Eta]T", P, "\[Phi]" -> False];
RBDVirtQ[name <> "-\[Eta]T", V, "\[Phi]" -> False];

(* w/ coefficients, get (h0-hd, h0dot-hddot) *)
n = Length[P];
RBDConQ[name <> "-\[Eta]p", P, "\[Phi]" -> False];
RBDConQ[name <> "-\[Eta]p", -Pd, Thread["n" -> Range[n]], "\[Phi]" -> False];

n = Length@V;
RBDVirtQ[name <> "-\[Eta]v", V, "\[Phi]" -> False];
RBDVirtQ[name <> "-\[Eta]v", -Vd, Thread["n" -> Range[n]], "\[Phi]" -> False];

(* each component individually, get (h0, h0dot) or (hd, hddot) *)RBDConQ[name <> "-\[Eta]a", P, "\[Phi]" -> False];
RBDVirtQ[name <> "-\[Eta]a", V, "\[Phi]" -> False];

RBDConQ[name <> "-\[Eta]d", Pd, "\[Phi]" -> False];
RBDVirtQ[name <> "-\[Eta]d", Vd, "\[Phi]" -> False];

(* slopes given stance and swing foot constraints *)
RBDConQ[name <> "-\[Sigma]", S];

(* data *)
n = name <> "-" <>  #& /@ {"p", "v", "u", "b", "\[Eta]0", "\[Eta]T", "\[Eta]p", "\[Eta]v"};
m = {"\[Alpha]0", "\[Alpha]T", "\[Alpha]f"};
m = <|MapThread[Rule, {m, Values@PT[[{"\[Eta]0", "\[Eta]T", "\[Alpha]"}, 1]]}]|>;
RBDParameters[nx + n\[Mu]T + Length[PT["c"]]];
<|
"f" -> <|name -> n[[1;;4]]|>,
"h" -> <|name -> name <> "-i"|>,
"\[Eta]0" -> <|name -> name <> "-\[Eta]0"|>,
"\[Eta]T" -> <|name -> name <> "-\[Eta]T"|>,
"\[Eta]p" -> <|name -> name <> "-\[Eta]p"|>,
"\[Eta]v" -> <|name -> name <> "-\[Eta]v"|>,
"\[Eta]a" -> <|name -> name <> "-\[Eta]a"|>,
"\[Eta]d" -> <|name -> name <> "-\[Eta]d"|>,
"J[p]" -> <|name -> name <> "-\[Eta]p"|>,
"\[Sigma]" -> <|name -> name <> "-\[Sigma]"|>,
"B0" -> <|n[[5]] -> PT["B0"]|>,
"\[Alpha]0" -> <|n[[5]] -> PT[["\[Eta]0"]]|>,
"BT" -> <|n[[6]] -> PT["BT"]|>,
"\[Alpha]T" -> <|n[[6]] -> PT[["\[Eta]T"]]|>,
"\[Alpha]\[Theta]" -> <|name <> "-i" -> \[Theta][[2]]|>,
"\[Alpha]J[p]" -> <|name <> "-\[Eta]p" -> J|>,
"\[Theta]" -> <|name -> rbdind@\[Theta][[1, {1,3,4}]]|>,
"t" -> <|name -> dt|>,
"nc" -> <|name -> nc|>,
"np" -> <|name -> Length[P]|>,
"nv" -> <|name -> Length[V]|>,
"nu" -> <|name -> Length[B]|>,
"P" -> <|n[[3]] -> Pcon|>,
"\[Alpha]" -> <|name -> m|>,
"M" -> <|name -> M|>
|>
];


(* ::Input::Initialization:: *)
xT[name_, data_] := Module[{ST, SW, A, \[Theta]T, n, m, qT, vsw, vst, o},
(* called with post-impact stance but pre-impact state *)
(* in other words, function is called with m = m(0^+), but c = c(0^-) *)
ST = data["ST"];
SW = data["SW"];
A = data["A"];
\[Theta]T = data["\[Theta]T"];
o = Sequence["\[Phi]" -> False, "Kp" -> 0, "Kv" -> 0];

If[A === {}, Throw@$Failed];

(* compute x(T-) = A.x(0-) + b *)

(* the configurations are straightforward, just apply A.q(0-) *)
qT = A[[1;;nq, 1;;nq]].RBDGetValue[1, nq, "n" -> False];

(* apparently this formula is just given by user symbolically *)
(* \[Theta] = \[Theta]T *)
m = RBDGetIndex[\[DoubleStruckQ]["\[Theta]", 1]];
qT[[m]] = \[Theta]T;

n = name <> "-xT";
RBDConQ[n , qT, o]; (* will also generate velocity constraints *)

(* is \[Theta]T a constant? don't change velocity. *)
If[PossibleZeroQ@Norm@D[\[Theta]T, {RBDGetValue[1, nq, "n" -> False]}], 
RBDConV[n, \[DoubleStruckV]["\[Theta]", 1], "n" -> m, o]
];

(* the following is meant to address 3D bipeds using the vector r *)
(* when the robot walks forward, the position variables *)
(* in the sagittal walking plane translate forward, while *)
(* the motion perpendicular to the plane is reflected about the *)
(* walking plane *)

(* (x[T-], y[T-], z[T-]) = swing[0-] + r (p[0-] - stance[0-]) *)
(* r = {1, -1, 1} assuming walking occurs in x-z plane *)
(* p[0-] = (x[0-], y[0-], z[0-]) *)

(* need to flip sign on ST *)
If[ST =!= {},
m = data["|_"]; (* multiplier for r in ST *)
If[m === Automatic,
m = BLIndices[BLGetBipedBase[], "p"];
m = Pick[Range@Length@m, Diagonal[A[[m ,m]]], _?Positive];
];
(* we can apply math operations with resulting Jacobians using r *)
ST[[m]] = ST[[m]] /. \[DoubleStruckB][b_, r_, o___] :> \[DoubleStruckB][b, -r, o];
];

(* remove velocities due to ST and SW *)
{vsw, vst} = {SW, ST} /. \[DoubleStruckB][b_, r_, o___] :> \[DoubleStruckB]'[b, -r, o];

(* as holonomic constraints, ST and SW add their velocities *)
(* to the resulting output function \[Eta], so we subtract with vsw and vst *)
(* this is another example of performing basic math with constraints *)

(* add ST and SW constraints *)
m = BLIndices[BLGetBipedBase[], "p"];
m = Thread["n" -> m];

(* stance *)
If[Length@ST != Length@m, 
RBDConQ[n, ST, #, o]& /@ m, 
RBDConQ[n, ST, m, o]
];

If[Length@vst != Length@m,
RBDConV[n, vst, #, o]& /@ m, 
RBDConV[n, vst, m, o];
];

(* swing *)
If[Length@SW != Length@m,
RBDConQ[n, SW, #, o]& /@ m, 
RBDConQ[n, SW, m, o];
];

If[Length@vsw != Length@m,
RBDConV[n, vsw, #, o]& /@ m, 
RBDConV[n, vsw, m, o];
];

<|"xT" -> <|name -> n|>|>
]


(* ::Input::Initialization:: *)
Options[BLRegime] = {"P" -> {}, "V" -> {}, "B" -> Automatic, "I" -> Automatic, "M" -> Automatic, "\[Theta]" -> {{\[DoubleStruckQ]["\[Theta]", 1], \[DoubleStruckV]["\[Theta]", 1], 0, \[DoubleStruckC][-1]}, {0, 0}}, "Pcon" -> {}, "n\[Mu]" -> 0, "dt" -> {0, -1}, "J[p]" :>  Automatic, "S" -> {}, Association -> <||>};

BLRegime[name_, opts:OptionsPattern[]] := Module[{r, K}, 
(* defaults for \[Theta] & dt assume one switching time; J[p] assumes 6D base. *)
r = OptionValue[Association];
K = Select[Keys@Options@BLRegime, StringQ];
Do[r[k] = OptionValue[k];, {k, K}];

If[r["J[p]"] === Automatic, 
K = BLIndices[BLGetBipedBase[], "p"];
r["J[p]"] = {K, Range@Length@K};
];

(* expand constraints *)
r = Join[r, BLConstraints[r["P"], r["V"], r["S"], r["B"], r["I"]]];

<|name -> r|>
];

BLConstraints[P_, V_, S_, B_:Automatic, I_:Automatic] := Module[{f, p, v, b, i, s, M},
f = Which[
MemberQ[{\[DoubleStruckQ], \[DoubleStruckV], \[DoubleStruckB], Plus}, Head[#]], #, 
VectorQ@#, BLValues@@#, 
Length[#] == 2 && StringQ[#[[1]]], BLFeet[#, Automatic][1],
True, BLValues@#]&;

(* constraints *)
p = Map[f, KeySort@P, {2}];
v = Map[f, KeySort@V, {2}];
i = Map[f, KeySort@If[I === Automatic, P, I], {2}];

(* polynomial degrees *)
b = Merge[{p, v}, Join@@#&];
M = KeyValueMap[ConstantArray[#1, Length@Flatten@#2]&, b];

(* reshape *)
p = Flatten@Values@p;
v = Flatten@Values@v;
i = Flatten@Values@i;
M = Flatten@M;

(* transmission matrix *)
b = If[B === Automatic, v /. {\[DoubleStruckQ] -> \[DoubleStruckV], \[DoubleStruckB] -> Derivative[1][\[DoubleStruckB]]}, B];

s = Range@Length@S;
If[s =!= {}, s = Flatten@Values[BLFeet[S, 3][[Thread@Key@s]]];];

(* convert to indices in dof *)
f = Function[x, If[MemberQ[{\[DoubleStruckB], Plus}, Head[x]], x, RBDGetValue@RBDGetIndex@x], Listable];

{p, v, b, s, i} = f@{p, v, b, s, i};

Association@{"P" -> p, "V" ->  v, "B" -> b, "M"  -> M, "I" -> i, "S" -> s}
];


(* ::Input::Initialization:: *)
Options[BLxT] = {"ST" -> {}, "SW" -> {}, "A" -> {}, "|_" ->  Automatic, "\[Theta]T" -> \[DoubleStruckC][-1], Association -> <||>};

BLxT[name_, opts:OptionsPattern[]] := Module[{r, K}, 
r = OptionValue[Association];
K = Select[Keys@Options@BLxT, StringQ];
Do[r[k] = OptionValue[k];, {k, K}];

(* expand constraints *)
r = Join[r, Lookup[BLFeet[#, Automatic], 1, {}]& /@ r[[{"ST", "SW"}]]];
<|name -> r|>
];


(* ::Input::Initialization:: *)
BLCreateBiped[name_, C_, XT_, draw_, feet_, init_:<||>] := Module[{c, x, A},
BLbiped = Join[<|"name" -> name, "draw" -> draw, "feet" -> feet|>, init];

c = KeyValueMap[regime, C];
x = KeyValueMap[xT, XT];

A = Merge[Join[c, x], Join@@#&];

blmfCon[A["f"]];
blmhCon[A["h"]];
blmxTCon[A["xT"]];

blm\[Eta]0Con[A["\[Eta]0"]];
blmB0Con[A["B0"]];
blm\[Alpha]0Con[A["\[Alpha]0"]];

blm\[Eta]TCon[A["\[Eta]T"]];
blmBTCon[A["BT"]];
blm\[Alpha]TCon[A["\[Alpha]T"]];

blm\[Alpha]\[Theta]Con[A["\[Alpha]\[Theta]"]];

blm\[Eta]pCon[A["\[Eta]p"]];
blm\[Eta]vCon[A["\[Eta]v"]];

blm\[Eta]aCon[A["\[Eta]a"]];
blm\[Eta]dCon[A["\[Eta]d"]];

blmJpCon[A["J[p]"]];
blm\[Alpha]JpCon[A["\[Alpha]J[p]"]];

blmPCon[A["P"]];

blmDTCon[A["t"]];

blm\[Sigma]Con[A["\[Sigma]"]];

RBDParameters[Max@A["nc"]];
A[["nc", All]] = nc;

BLbiped["\[Alpha]"] = A["\[Alpha]"];

A
]


(* ::Input::Initialization:: *)
End[]
EndPackage[]
