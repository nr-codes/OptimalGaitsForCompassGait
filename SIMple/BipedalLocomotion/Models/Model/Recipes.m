(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
CoreDynamicAlgorithms.nb: An implementation of the RNEA algorithm
and its derivative.
Copyright (C) 2017 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`Model`", {"GlobalVariables`", "RigidBodyDynamics`", "BipedalLocomotion`", "Derivatives`"}]

Begin["`Private`"]


(* ::Input::Initialization:: *)
\[Theta]0[] := Module[{eta}, 
Which[
\[Alpha]\[Theta][[1]] != 0,
(* is clock value given by a constraint? *)
RigidBodyDynamics`Private`q[[1]] = RigidBodyDynamics`Private`\[Eta][[1, \[Alpha]\[Theta][[1]]]];,
\[Alpha]\[Theta][[2]] == 0,
(* reset to zero *)
RigidBodyDynamics`Private`q[[1]] = z1;
]
(* else clock is time based, leave it alone *)
];

\[Eta]0[] := Module[{c0, eta, \[Alpha]},
c0 = \[DoubleStruckC];

If[Length@\[Alpha]0[[2]] > 0,
eta = Join[RigidBodyDynamics`Private`\[Eta][[1]], RigidBodyDynamics`Private`\[Eta][[2]]];
eta = eta[[\[Alpha]0[[2]]]];
\[Alpha] = LinearSolve[B0fun, eta];
c0[[\[Alpha]0[[1]]]] = \[Alpha];
];
Flatten[{c0}]
];

\[Eta]T[] := Module[{cT, eta, \[Alpha]},
cT = \[DoubleStruckC];

If[Length@\[Alpha]T[[2]] > 0,
eta = Join[RigidBodyDynamics`Private`\[Eta][[1]], RigidBodyDynamics`Private`\[Eta][[2]]];
eta = eta[[\[Alpha]T[[2]]]];
\[Alpha] = LinearSolve[BTfun, eta];
cT[[\[Alpha]T[[1]]]] = \[Alpha];
];
Flatten[{cT}]
];

Ucon[] := Module[{bv, nqf, nqfv, nqfub},
nqf = nq + nf;
nqfv = nq + nf + nv;
nqfub = nq + nf + nu + 1;
If[nf > 0 && nv > 0 && Length@Pfun > 0, 
bv = Pfun.RigidBodyDynamics`Private`Ab[[nqf+1;;nqfv, nqfub]];
RigidBodyDynamics`Private`Ab[[nqf+1;;nqfv, nqfub]] = bv;
];
];

Jac[] := Module[{x, i, j, A, b},
i = \[Alpha]Jp[[2]];
j = \[Alpha]Jp[[1]];

A = RigidBodyDynamics`Private`J[[i, j]];
b = -RigidBodyDynamics`Private`\[Eta][[2, i]];
x = LinearSolve[A, b];
Flatten[{x}]
];

\[Sigma][]:= Module[{st, sw, a, ret},
st = RigidBodyDynamics`Private`\[Eta][[1, 1;;mm]];
sw = RigidBodyDynamics`Private`\[Eta][[1, mm+1;;nm]];

(* difference of foot locations *)
a = sw - st;
ret = z3;

If[a[[2]] != 0 || a[[3]] != 0, ret[[1]] = ArcTan[a[[2]], a[[3]]];];

If[a[[1]] != 0 || a[[3]] != 0, ret[[2]] = ArcTan[a[[1]], a[[3]]];];

If[a[[1]] != 0 || a[[2]] != 0, ret[[3]] = ArcTan[a[[1]], a[[2]]];];

Flatten[{ret}]
];


(* ::Input::Initialization:: *)
blmfCon[cons_] := Module[{F, confun},
F = <|"f" :> {RigidBodyDynamics`Private`UpperTriangularizeAb, Ucon, RigidBodyDynamics`Private`F}, "v" :> {{Pfun, _Real, 2}}|>;
F = RBDMergeRecipes["FMbJ", F];
F["C"] = cons;
con["f"] = F
];

blmhCon[cons_] := Module[{H},
H = <|"f" :> {\[Theta]0, RigidBodyDynamics`Private`H}, "d" :> {{\[Alpha]\[Theta], _Integer, 1}}|>;

H = RBDMergeRecipes["HMbJ", H];
H["C"] = cons;
con["h"] = H
];

blm\[Eta]0Con[cons_] := Module[{E},
E = <|"f" :> {\[Eta]0}, "v" :> {{B0fun, _Real, 2}}, "d" :> {{\[Alpha]0, _Integer, 2}}|>;

E = RBDMergeRecipes["\[Eta]MbJ", E];
E["name"] = "\[Eta]0";
E["C"] = cons;
con["\[Eta]0"] = E
];

blm\[Eta]TCon[cons_] := Module[{E},
E = <|"f" :> {\[Eta]T}, "v" :> {{BTfun, _Real, 2}}, "d" :> {{\[Alpha]T, _Integer, 2}}|>;
E = RBDMergeRecipes["\[Eta]MbJ", E];

E["name"] = "\[Eta]T";
E["C"] = cons;
con["\[Eta]T"] = E
];

blm\[Eta]pCon[cons_] := Module[{E},
E = RBDGetRecipe["\[Eta]MbJ"];
E["name"] = "\[Eta]p";
E["C"] = cons;
con["\[Eta]p"] = E
];

blm\[Eta]vCon[cons_] := Module[{E},
E = RBDGetRecipe["\[Eta]MbJ"];
E["name"] = "\[Eta]v";
E["C"] = cons;
con["\[Eta]v"] = E
];

blm\[Eta]aCon[cons_] := Module[{E},
E = RBDGetRecipe["\[Eta]MbJ"];
E["name"] = "\[Eta]a";
E["C"] = cons;
con["\[Eta]a"] = E
];

blm\[Eta]dCon[cons_] := Module[{E},
E = RBDGetRecipe["\[Eta]MbJ"];
E["name"] = "\[Eta]d";
E["C"] = cons;
con["\[Eta]d"] = E
];

blmJpCon[cons_] := Module[{E},
E = RBDMergeRecipes["\[Eta]MbJ", <|"f" :> {Jac}, "d" :> {{\[Alpha]Jp, _Integer, 2}}|>];
E["name"] = "J[p]";
E["C"] = cons;
con["J[p]"] = E
];

blmxTCon[cons_] := Module[{E},
E = RBDGetRecipe["\[Eta]MbJ"];
(*E = RBDMergeRecipes["\[Eta]MbJ", <|"f" \[RuleDelayed] {xTTest}|>];*)
E["name"] = "xT";
E["C"] = cons;
con["xT"] = E
];

blm\[Sigma]Con[cons_] := Module[{E},
E = RBDMergeRecipes["\[Eta]MbJ", <|"f" :> {\[Sigma]}|>];
E["name"] = "\[Sigma]";
E["C"] = cons;
con["\[Sigma]"] = E
];

blmPCon[cons_] := con["P"] = cons;
blmB0Con[cons_] := con["B0"] = cons;
blmBTCon[cons_] := con["BT"] = cons;
blm\[Alpha]0Con[cons_] := con["\[Alpha]0"] = cons;
blm\[Alpha]TCon[cons_] := con["\[Alpha]T"] = cons;
blm\[Alpha]\[Theta]Con[cons_] := con["\[Alpha]\[Theta]"] = cons;
blm\[Alpha]JpCon[cons_] := con["\[Alpha]J[p]"] = cons;
blmDTCon[cons_] := con["t"] = cons;


(* ::Input::Initialization:: *)
blmp[cons_] := con["p"] = cons;
blmcT[cons_] := con["cT"] = cons;


(* ::Input::Initialization:: *)
End[]
EndPackage[]
