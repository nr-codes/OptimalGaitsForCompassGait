(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
OperationalSpace.nb: An implementation of the OSIM algorithm
and its derivative.
Copyright (C) 2014 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["RigidBodyDynamics`", "GlobalVariables`"]
RBDJ2::usage = "";
RBD\[Eta]2::usage = "";
Begin["`Private`"]


(* ::Input::Initialization:: *)
(* 
user inputs: none;
zeroed inputs: XL0, X0L, XL0dot, X0Ldot;
model data: XL, XLdot, parent, nq;
modifies: XL0, X0L, XL0dot, X0Ldot;
output: XL0, X0L, XL0dot, X0Ldot (transforms from/to root)
*)

(*X0[] := Module[{p, X, R, P},
timera = AbsoluteTime[];
(* compute transform X[b, 0] or X[o, 0] *)
XL0 = XL;
Do[p = parent\[LeftDoubleBracket]i\[RightDoubleBracket];  If[p > 0, X = XL0\[LeftDoubleBracket]i\[RightDoubleBracket]; XL0\[LeftDoubleBracket]i\[RightDoubleBracket] = X.XL0\[LeftDoubleBracket]p\[RightDoubleBracket]];, {i, bx}];
(* compute inverse transform *)
X0L = XL0;
Do[
R = X0L\[LeftDoubleBracket]i,1;;3,1;;3\[RightDoubleBracket]\[Transpose];
P = -X0L\[LeftDoubleBracket]i,4;;6,1;;3\[RightDoubleBracket];
X0L\[LeftDoubleBracket]i,1;;3,1;;3\[RightDoubleBracket] = R;
X0L\[LeftDoubleBracket]i,4;;6,4;;6\[RightDoubleBracket] = R;
X0L\[LeftDoubleBracket]i,4;;6,1;;3\[RightDoubleBracket] = R.P.R;,
{i, bx}
];

(* create corresponding rotation matrices *)
RL0 = XL0;
Do[RL0\[LeftDoubleBracket]i, 4;;6, 1;;3\[RightDoubleBracket] = Z3; ,{i, bx}];
R0L = Transpose[RL0, {1, 3, 2}];
timerb = AbsoluteTime[];
Print["X0: ", timerb - timera];
];*)


(* ::Input::Initialization:: *)
(*posX = Join[z3, position[#]]&;*)

(* assuming singularities won't occur *)
(*angX = {ArcTan[#\[LeftDoubleBracket]3,3\[RightDoubleBracket], -#\[LeftDoubleBracket]3,2\[RightDoubleBracket]], ArcSin[#\[LeftDoubleBracket]3,1\[RightDoubleBracket]], ArcTan[#\[LeftDoubleBracket]1,1\[RightDoubleBracket], -#\[LeftDoubleBracket]2,1\[RightDoubleBracket]]}&;

posX = position[#]&;*)

(*posX = Join[{ArcTan[#2\[LeftDoubleBracket]3,3\[RightDoubleBracket], -#2\[LeftDoubleBracket]3,2\[RightDoubleBracket]], ArcSin[#2\[LeftDoubleBracket]3,1\[RightDoubleBracket]], ArcTan[#2\[LeftDoubleBracket]1,1\[RightDoubleBracket], -#2\[LeftDoubleBracket]2,1\[RightDoubleBracket]]}, position[#1]]&;*)

(*V[] := Module[{p, vJ},
timera = AbsoluteTime[];
v = zspat;
Do[
p = parent\[LeftDoubleBracket]i\[RightDoubleBracket];
vJ = s\[LeftDoubleBracket]i\[RightDoubleBracket] qd\[LeftDoubleBracket]i\[RightDoubleBracket];
If[p \[Equal] 0, 
v\[LeftDoubleBracket]i\[RightDoubleBracket] = vJ;, 
v\[LeftDoubleBracket]i\[RightDoubleBracket] = XL\[LeftDoubleBracket]i\[RightDoubleBracket].v\[LeftDoubleBracket]p\[RightDoubleBracket] + vJ;
];, 
{i, nq}
];
timerb = AbsoluteTime[];
Print["V: ", timerb - timera];
];*)

(*rs0[] := Module[{Xdot, va, vb, vo0, vX, b, o, X, R},
timera = AbsoluteTime[];

(* move joint and constraint vectors into world frame *)
sj = s; (* move s into world frame, sj = X[0, j].s[j, j] *)
sjdot = sdot; (* move sdot into world frame *)
Do[
sj\[LeftDoubleBracket]i\[RightDoubleBracket] = X0L\[LeftDoubleBracket]i\[RightDoubleBracket].s\[LeftDoubleBracket]i\[RightDoubleBracket];
vX = X0L\[LeftDoubleBracket]i\[RightDoubleBracket].v\[LeftDoubleBracket]i\[RightDoubleBracket];
Xdot = mxX[vX, X0L\[LeftDoubleBracket]i\[RightDoubleBracket]];
sjdot\[LeftDoubleBracket]i\[RightDoubleBracket] = X0L\[LeftDoubleBracket]i\[RightDoubleBracket].sdot\[LeftDoubleBracket]i\[RightDoubleBracket] + Xdot.s\[LeftDoubleBracket]i\[RightDoubleBracket];,
{i, bs}
];

Xo0 = Tcb;
ro = r;
rodot = rdot;
posXco = zpos;

Do[
b = bo\[LeftDoubleBracket]k, 1\[RightDoubleBracket];
o = bo\[LeftDoubleBracket]k, 2\[RightDoubleBracket];

(* compute X transform from 0 (root/world frame) to o *)
(* transforms are root \[Rule] b \[Rule] c \[Rule] 0, i.e, X[o, c].X[c, b].X[b, 0] *)
If[o \[Equal] 0, 
Xo0\[LeftDoubleBracket]k\[RightDoubleBracket] = R0L\[LeftDoubleBracket]b\[RightDoubleBracket].Tcb\[LeftDoubleBracket]k\[RightDoubleBracket].XL0\[LeftDoubleBracket]b\[RightDoubleBracket];
R = RL0\[LeftDoubleBracket]b\[RightDoubleBracket];
X = Xo0\[LeftDoubleBracket]k\[RightDoubleBracket];, 
Xo0\[LeftDoubleBracket]k\[RightDoubleBracket] = RL0\[LeftDoubleBracket]o\[RightDoubleBracket].R0L\[LeftDoubleBracket]b\[RightDoubleBracket].Tcb\[LeftDoubleBracket]k\[RightDoubleBracket].XL0\[LeftDoubleBracket]b\[RightDoubleBracket];
R = RL0\[LeftDoubleBracket]b\[RightDoubleBracket].R0L\[LeftDoubleBracket]o\[RightDoubleBracket];
X = Xo0\[LeftDoubleBracket]k\[RightDoubleBracket].X0L\[LeftDoubleBracket]o\[RightDoubleBracket];
];

(* spatial position of constraint in o frame *)
posXco\[LeftDoubleBracket]k\[RightDoubleBracket] = r\[LeftDoubleBracket]k\[RightDoubleBracket].posX[X, R];

(* move r into world frame, ro = r[o, o].X[o, 0] *)
ro\[LeftDoubleBracket]k\[RightDoubleBracket] = r\[LeftDoubleBracket]k\[RightDoubleBracket].Xo0\[LeftDoubleBracket]k\[RightDoubleBracket];

(* move rdot into world frame, rodot = d/dt(r[o, o].X[o, 0]) *)
va = v\[LeftDoubleBracket]b\[RightDoubleBracket];
va\[LeftDoubleBracket]4;;6\[RightDoubleBracket] = z3; (* only angular vel of vb *)
vo0 = R0L\[LeftDoubleBracket]b\[RightDoubleBracket].va-R0L\[LeftDoubleBracket]b\[RightDoubleBracket].Tcb\[LeftDoubleBracket]k\[RightDoubleBracket].v\[LeftDoubleBracket]b\[RightDoubleBracket]; (* vel w/ o = 0 *)
If[o \[NotEqual]  0, 
va = v\[LeftDoubleBracket]o\[RightDoubleBracket];
va\[LeftDoubleBracket]4;;6\[RightDoubleBracket] = z3; (* only angular vel of vo *)
vb = RL0\[LeftDoubleBracket]o\[RightDoubleBracket].vo0; (* avoid multiplication bug *)
vo0 = vb - va;
];
Xdot = mxX[vo0, Xo0\[LeftDoubleBracket]k\[RightDoubleBracket]];
rodot\[LeftDoubleBracket]k\[RightDoubleBracket] =  rdot\[LeftDoubleBracket]k\[RightDoubleBracket].Xo0\[LeftDoubleBracket]k\[RightDoubleBracket] + r\[LeftDoubleBracket]k\[RightDoubleBracket].Xdot;, 
{k, Length@bo}
];

timerb = AbsoluteTime[];
Print["rs0: ", timerb - timera];
];*)


(* ::Input::Initialization:: *)
(* 
user inputs: none;
zeroed inputs: XL0, X0L, XL0dot, X0Ldot;
model data: XL, XLdot, parent, nq;
modifies: XL0, X0L, XL0dot, X0Ldot;
output: XL0, X0L, XL0dot, X0Ldot (transforms from/to root)
*)

R0[] := Module[{p, R0L},
(*timera = AbsoluteTime[];*)
(* compute transform R[0, b] *)
R0L = XL;
Do[
(* XL[i, p] = (R[i, p], p[i, p]) => R0L[0, i] = R0L[0, p].R[i, p]\[Transpose] *)
p = parent[[i]];
If[p > 0, 
R0L[[i, 1;;3, 1;;3]] = R0L[[p, 1;;3, 1;;3]].XL[[i, 1;;3, 1;;3]]\[Transpose];,
(* else *)
R0L[[i,1;;3,1;;3]] = XL[[i, 1;;3, 1;;3]]\[Transpose];
];

R0L[[i,4;;6,4;;6]] = R0L[[i,1;;3,1;;3]];
R0L[[i,4;;6,1;;3]] = Z3;,
{i, bx} (* bx must be ordered so that parent comes before child *)
];

(*Print["R0: ", AbsoluteTime[] - timera];*)
];


(* ::Input::Initialization:: *)
Josim[] := Module[{Xcj, b, k, n, jj, aa, vv, ii, kk, nn, j, ja, i, X, vc, vrel, Xdot, sc ,scdot, p, pos},
(*timera = AbsoluteTime[];*)

(* let {c'} be a frame at {c}, but with axes aligned w/ {0} *)
Xcj = Tcb;
(* compute X transform from {b} to {c'} *)
Do[
b = bo[[k, 1]]; 
Xcj[[k]] = R0L[[b]].Tcb[[k]];, 
{k, Length@bo}
];

(* compute J and \[Phi] in J.a + \[Phi] = 0*)
Do[
n = Length@ba[[c]];
{jj, aa, vv, ii, kk} = Select[ba[[c, 1;;n]], #[[4]] != 0&]\[Transpose];
nn = Length@ii;

(* all ba\[LeftDoubleBracket]i\[RightDoubleBracket]'s have same b (= j) and a in their arrays *)
j = ba[[c, 1, 1]];
ja = ba[[c, 1, 2]];
p = parent[[j]];

(* get all constraint i's and corresponding k's that would traverse *)(* the same path up the tree *)

(* perform (branch-induced) sparse matrix multiplication *)
While[j > ja,
Do[
i = ii[[cc]];
k = kk[[cc]];

(* {c'} => {c} in {b} with axes aligned with {0} *)
X = Xcj[[k]];
vc = X[[4;;6]].v[[j]];  (* {c'} is not rotating *)

(* compute d/dt Xc *)
vrel = X.v[[j]];
vrel[[4;;6]] = vrel[[4;;6]] - vc;
Xdot = mxX[vrel, X];

(* compute s in {c} *)
sc = X.s[[j]];
scdot = Xdot.s[[j]] + X.sdot[[j]];

(* compute J *)
J[[i, j]] = J[[i, j]] + r[[k]].sc;

(* compute \[Phi] = \[Phi] + Jdot qd *)
\[Phi][[i]] = \[Phi][[i]] + (rdot[[k]].sc + r[[k]].scdot) qd[[j]];

(* compute hdot, \[Eta] = (h, hdot) *)
(* also useful for constraint stabilization *)
If[vv[[k]] <= 1, \[Eta][[2, i]] = \[Eta][[2, i]] + J[[i, j]] qd[[j]];];

(* continue up the path *)
Xcj[[k]] = X.XL[[j]];

(* compute h, \[Eta] = (h, hdot) *)
If[p == ja && vv[[k]] <= 0,
pos = position[Xcj[[k]]];
\[Eta][[1, i]] = \[Eta][[1, i]] + r[[k, 4;;6]].pos;
];,
{cc, nn}
];

j = p;
If[j > 0, p = parent[[j]];];
];,
{c, Length@ba}
];

(*Print["JOSIM2: ", AbsoluteTime[] - timera];*)
];


(* ::Input::Initialization:: *)
RBDJ2[x_:{}, \[Lambda]_:{}] := Module[{p, vJ},
s = sfun[x, \[Lambda]];
sdot = sdotfun[x, \[Lambda]];
XL = XLfun[x, \[Lambda]];

r = rfun[x, \[Lambda]];
rdot = rdotfun[x, \[Lambda]];
Tcb = Tcbfun[x, \[Lambda]];
J = Jfun[x, \[Lambda]];
\[Phi] = \[Phi]fun[x, \[Lambda]];
\[Eta] = \[Eta]fun[x, \[Lambda]];
K = Kfun[x, \[Lambda]];

bo = rb[C, "bo"];
ba = rb[C, "ba"];
bs = rb[C, "bs"];
bx = rb[C, "bx"];

(* for computing Xdot *)
qd = If[x === {}, Array[\[DoubleStruckX], nq, nq+1], x[[nq+1;;nx]]];

V[];
R0[];
Josim[];
{J, \[Phi]}
];

RBD\[Eta]2[x_:{}, \[Lambda]_:{}] := Module[{},
RBDJ2[x, \[Lambda]];
\[Eta]
];



(*Josim[] := Module[{Xcj, b, k, n, jj, aa, vv, ii, kk, nn, j, ja, i, X, vc, vrel, Xdot, sc ,scdot, p, pos},
Xcj = Tcb;

(* compute J and \[Phi] in J.a + \[Phi] = 0*)
Do[
n = Length@ba\[LeftDoubleBracket]c\[RightDoubleBracket];
{jj, aa, vv, ii, kk} = Select[ba\[LeftDoubleBracket]c, 1;;n\[RightDoubleBracket], #\[LeftDoubleBracket]4\[RightDoubleBracket] \[NotEqual] 0&]\[Transpose];
nn = Length@ii;

(* all ba\[LeftDoubleBracket]i\[RightDoubleBracket]'s have same b (= j) and a in their arrays *)
j = ba\[LeftDoubleBracket]c, 1, 1\[RightDoubleBracket];
ja = ba\[LeftDoubleBracket]c, 1, 2\[RightDoubleBracket];
p = parent\[LeftDoubleBracket]j\[RightDoubleBracket];

(* get all constraint i's and corresponding k's that would traverse *)(* the same path up the tree *)

(* perform (branch-induced) sparse matrix multiplication *)
While[j > ja,
Do[
i = ii\[LeftDoubleBracket]cc\[RightDoubleBracket];
k = kk\[LeftDoubleBracket]cc\[RightDoubleBracket];

(* {c'} => {c} in {b} with axes aligned with {0} *)
X = Xcj\[LeftDoubleBracket]k\[RightDoubleBracket];
(* continue up the path *)
Xcj\[LeftDoubleBracket]k\[RightDoubleBracket] = X.XL\[LeftDoubleBracket]j\[RightDoubleBracket];

(* compute h, \[Eta] = (h, hdot) *)
If[p \[Equal] ja && vv\[LeftDoubleBracket]k\[RightDoubleBracket] \[LessEqual] 0,
pos = position[Xcj\[LeftDoubleBracket]k\[RightDoubleBracket]];
\[Eta]\[LeftDoubleBracket]1, i\[RightDoubleBracket] = \[Eta]\[LeftDoubleBracket]1, i\[RightDoubleBracket] + r\[LeftDoubleBracket]k, 4;;6\[RightDoubleBracket].pos;
];,
{cc, nn}
];

j = p;
If[j > 0, p = parent\[LeftDoubleBracket]j\[RightDoubleBracket];];
];,
{c, Length@ba}
];
];*)


(* ::Input::Initialization:: *)
End[]
EndPackage[]
