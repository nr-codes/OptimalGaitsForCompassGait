(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`Model`", {"GlobalVariables`", "RigidBodyDynamics`", "HybridDynamics`", "BipedalLocomotion`"}]

Begin["`Private`"]

cfun = Partition[#2[[{}]], nq]&;
tfun = #2[[{}]]&;


(* ::Input::Initialization:: *)
Options[CompileWithInputSpline] = {"a" -> {1, 2, 3}, CompilationTarget -> "C", CompileDeBoor -> {}, BLCompileBiped -> {}};

CompileWithInputSpline[n_, ci_, ti_, OptionsPattern[]] := Module[{u, s, k},
(* remove ufun from list of compiled pure functions *)
s = RigidBodyDynamics`Private`spatfun;
s = Position[s, HoldPattern@{ufun, {__}}];
s = Delete[RigidBodyDynamics`Private`spatfun, s];

(* compile functions assuming ufun is 3rd in "v" array of fcn dfns *)
BLCompileBiped[n, 
OptionValue@BLCompileBiped,
Compile -> {"f" -> {CompilationOptions->{"InlineCompiledFunctions"->True, "ExpressionOptimization"->True}, CompilationTarget -> OptionValue@CompilationTarget}, "S" -> s, "a" -> OptionValue@"a"}];

k = Keys@BLbiped["m"];
u = CompileDeBoor[n, ci, ti, OptionValue@CompileDeBoor, "M" -> k];

(* get compiled functions from con and update BLbiped *)
k = #["name"]& /@ GetCompilableFunctions[];
Do[
With[{a = BLbiped[i, j], b = u["u", j]}, 
BLbiped[i, j] = a[##, devec[b[##], nq]]&;
];,
{i, k}, {j, Keys@u["u"]}
];

BLbiped["u"] = u["u"];

\[CurlyPhi][BLbiped, n];

BLbiped
];


(* ::Input::Initialization:: *)
Options[CompileDeBoor] = {"M" -> {"left", "right"}};
CompileDeBoor[n_, ci_, ti_, OptionsPattern[]] := Module[{r, s, c, t, m, ca, ta},
m = OptionValue["M"];

(* based on mode m, return a function *)
Which[
AssociationQ[ci], ca = ci;, 
VectorQ[ci, IntegerQ], ca = (Partition[#2[[ci]], nq]&)&;, 
True, ca = (ci&);
];

Which[
AssociationQ[ti], ta = ti;, 
VectorQ[ti, IntegerQ], ta = (#2[[ti]]&)&;, 
True, ta = (ti&);
];

r = <|
"name" -> "u",
"f" :> {deBoor},
"lcls" :> {},
"v" :> {{\[DoubleStruckX], _Real, 1}, {\[DoubleStruckC], _Real, 1}, {cfun, _Real, 2}, {tfun, _Real, 1}, {RigidBodyDynamics`Private`zq, _Real, 1}},
"d" :> {},
"I" :> {},
"O" :> {},
"C" -> AssociationThread[m -> m]
|>;

s = <|
"I" :> {{RigidBodyDynamics`Private`zq, {{\[DoubleStruckX], _Real, nx}}}}, 
"O" :> {}
|>;

c = <|
"I" :> {{cfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}}, 
{tfun, {{\[DoubleStruckX], _Real, nx}, {\[DoubleStruckC], _Real, nc}}}}, 
"O" :> {}
|>;

Block[{RBDConstraintFunctions = (cfun = ca[#]; tfun = ta[#];&)},
RBDCompileFunction[{r}, n, "S" -> s, "C" -> c,  "D" -> {}]
]
];


(* ::Input::Initialization:: *)
deBoor[] := Module[{x, t, c, i, d, te, ts, a, b, p, n, ret},
t = tfun;
c = cfun;
ret = RigidBodyDynamics`Private`zq;

n = Length[c] - 1;
p = (Length[t] - 1) - n - 1; (* m - n - 1 *)

(*x = (\[DoubleStruckX]\[LeftDoubleBracket]1\[RightDoubleBracket] - \[DoubleStruckC]\[LeftDoubleBracket]1\[RightDoubleBracket])/\[DoubleStruckC]\[LeftDoubleBracket]-1\[RightDoubleBracket];*)
x = \[DoubleStruckX][[1]](* - \[DoubleStruckC]\[LeftDoubleBracket]1\[RightDoubleBracket]*);
If[t[[p+1]] <= x < t[[n+2]],
i = Select[Range[p, n], t[[#+1]] <= x < t[[#+2]]&][[-1]] + 1;
d = c[[i-p;;i]];
Do[
ts = t[[j + i - p]];
te = t[[j + 1 + i - r]];
a = (x - ts)/(te - ts);
(* avoid issue with lhs = rhs issue (see DifferentiateFunctions.nb) *)
b = (1 - a) d[[j]] + a d[[j+1]];
d[[j + 1]] = b;,
{r, 1, p}, {j, p, r, -1}
];
ret = d[[p + 1]];
];

Flatten[{ret}]
];


(* ::Input::Initialization:: *)
Options[KnotsDTT] = {"T" -> Automatic, "DT" -> Automatic, "i" -> {0, 0}, "p" -> Automatic};

KnotsDTT[m_, c_,OptionsPattern[]] := Module[{p, D, T, e},
(* t[p+1]..t[-p-1] have full support *)
(* +'ve #'s shrink the interval (and continue to have full support *)
(* -'ve #'s grow the interval (outside range of full support *)
p = OptionValue["p"];
If[p === Automatic, p = BLbiped["spline", "p"];];

e = OptionValue["i"] + 1;
D = OptionValue["DT"];
If[D === Automatic, D = BLbiped["t", m]];

T = OptionValue["T"];
If[T === Automatic, T = BLGetSwitchingTimes[c, "m" -> m, "DT" -> D];];

D = D[[p+e[[1]];;-(p+e[[2]])]];
T = T[[p+e[[1]];;-(p+e[[2]])]];

(* to get multiple switching times working for BLWalk and friends *)
If[Length@D < Length@T, D= PadRight[D, Length@T];];

(* gather same switching times together *)
T = GatherBy[{D, T}\[Transpose], Last][[All, -1]];
{D, T} = If[T === {}, {{}, {}}, Transpose@T];

p = {HybridDynamics`Private`TFaux -> TFaux, HybridDynamics`Private`TF -> TF};
e = AddSwitchingTimeEvents[T, D] /. p;

(* delete TF at 1st impact event (assuming T\[LeftDoubleBracket]1\[RightDoubleBracket] = DT\[LeftDoubleBracket]1\[RightDoubleBracket] = 0) *)
(*e = Delete[e, {{1,2,1}, {1,2,2}}];*)

{D, T, e}
];


(* ::Input::Initialization:: *)
SplineSim[c_, opts:OptionsPattern[]] := SplineSim[BLbiped["m[0]"], c, opts];

SplineSim[m_String, c_, opts:OptionsPattern[{BLMap,KnotsDTT}]] := Module[{DT, T, e, o},
o = FilterRules[{opts}, Options@KnotsDTT];
{DT, T, e} = KnotsDTT[m, c, o];

o = FilterRules[{opts}, Options@BLMap];
BLSim[m, c, "DT" -> DT, "T" -> T, "e" -> e, o]
];


(* ::Input::Initialization:: *)
(*BLSplineSim[c_, opts:OptionsPattern[]] := BLSplineSim[BLbiped["m[0]"], c, opts];

(* we integrate a step over t[p+2]..t[-p-1], unless changed *)
BLSplineSim[m_String, c_, opts:OptionsPattern[]] := SplineSim[m, c, opts, "i" \[Rule] {1, 0}];*)


(* ::Input::Initialization:: *)
TF[m_, x_?VectorQ, c_?VectorQ, i_Integer, d_:100 $MachineEpsilon] := Module[{k, xpre, t},
k = RBDGetIndex[\[DoubleStruckQ]["\[Theta]", 1]];
xpre = x;
t = xpre[[k]];
(* make sure to get pre-impact derivative *)
xpre[[k]] = t - d;
xpre = HybridDynamics`Private`TF[m, xpre, c, i];
(* restore previous value *)
xpre[[k]] = t;
xpre
];

TFaux[m_, x_?VectorQ, c_?VectorQ, a_?VectorQ, i_Integer, d_:100 $MachineEpsilon] := Module[{k, xpre, t},
k = RBDGetIndex[\[DoubleStruckQ]["\[Theta]", 1]];
xpre = x;
t = xpre[[k]];
(* make sure to get pre-impact derivative *)
xpre[[k]] = t - d;
xpre = HybridDynamics`Private`TFaux[m, xpre, c, a, i];
(* restore previous value *)
xpre[[k]] = t;
xpre
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
