(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
SimplestModel.nb: An implementation of various continuation methods.
Copyright (C) 2017 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["HybridDynamics`", "GlobalVariables`", "BipedalLocomotion`"]

Begin["`Private`"]
nd = $Failed;


(* ::Input::Initialization:: *)
Aaux = <|"t0" -> <||>, "f" -> <||>, "h" -> <||>|>;

(* indirectly access Aaux to deal w/ missing keys *)
aux[k_, m_, x_, c_] := Module[{X, C},
X = devec[x, nx];
C = devec[c, nc];
Flatten@If[KeyExistsQ[Aaux[k], m], Aaux[k, m][X, C], 0.0 X[[All, 1]]]
];

aux0[m_, x_?VectorQ, c_?VectorQ] :=aux["t0", m, x, c];

faux[m_, x_?VectorQ, c_?VectorQ] := aux["f", m, x, c];

haux[m_, x_?VectorQ, c_?VectorQ] := aux["h", m, x, c];

Taux[m_, x_, c_] := Module[{FC, xdot, xt, ct, FT},
FC = devec[aux["f", m, x, c]];

xdot = f[m, x, c];
xt = Join[x[[1;;nx]], xdot[[1;;nx]], ConstantArray[0.0, nx]];
ct = Join[c[[1;;nc]], ConstantArray[0.0, 2nc]];
(* we can't do no-arg devec b/c nd = 1 in this case, where we want df/dt *)
FT = devec[aux["f", m, xt, ct], Length@FC[[1]]];

{FC, FT}
];

T0aux[m_, x_?VectorQ, c_?VectorQ, a_?VectorQ, i_Integer] := Module[{FC, FT},
{FC, FT} = Taux[m, x, c];
Sow[DT0[devec[a], FC, FT, i], "a+"]  (* note new form of devec *)
];

TFaux[m_, x_?VectorQ, c_?VectorQ, a_?VectorQ, i_Integer] := Module[{FC, FT},
{FC, FT} = Taux[m, x, c];
Sow[DTF[devec[a], FC, FT, i], "a-"]
];

(* setter *)
\[CurlyPhi]aux[A_Association] := Module[{}, Aaux = A];


(* ::Input::Initialization:: *)
devec::nd = "The number of derivatives has not been set.  For bipeds, a quick hack is to call \[CurlyPhi][\"nd\"].";

devec["nd"] := nd;

devec[v_] := Module[{n, N},
If[nd === $Failed,
Message[devec::nd];
Throw@nd;
];

(* https://en.wikipedia.org/wiki/Geometric_series#Closed-form_formula *)
N = If[nd == 1, 2, (1-nd^(o+1))/(1-nd)];
n = Length[v]/N;
devec[v, n, nd]
];

devec[v_, n_] := Module[{m, N, x, dx, ddx},
N = Length[v]/n;
m = Switch[o, 0, 0, 1, N-1, 2, (-1+Sqrt[1-4(1-N)])/2];
devec[v, n, m]
];

devec[v_, n_, m_] := Module[{x, dx, ddx},
If[o >= 0, x = v[[1;;n]];];
If[o >= 1, dx = ArrayReshape[v[[n+1;;n (m+1)]], {n, m}];];
If[o >= 2, ddx = ArrayReshape[v[[n (m+1)+1;;n(m^2+m+1)]], {n, m, m}];];

{x,dx,ddx}[[1;;o+1]]
];


(* ::Input::Initialization:: *)
\[CurlyPhi]["nd"] := (nd = Max[Length /@ (Join@@@BLbiped["p"])]);


(* ::Input::Initialization:: *)
SetAttributes[{DefaultSwitchingEvent, AddSwitchingEvent}, HoldFirst];

Options[DefaultSwitchingEvent] = {"i" -> 3;;-3, "p" -> {}, "a" -> {}, WhenEvent -> {}, "DT" -> 0};

(* order of events might matter here for a and x *)
Events[k_:0] := {\[DoubleStruckA][\[DoubleStruckT]] -> TFaux[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], \[DoubleStruckA][\[DoubleStruckT]], k], \[DoubleStruckX][\[DoubleStruckT]] -> TF[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], k], \[DoubleStruckM][\[DoubleStruckT]] -> m[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]]], \[DoubleStruckX][\[DoubleStruckT]] -> h[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]]], \[DoubleStruckC][\[DoubleStruckT]] -> d[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]]], \[DoubleStruckA][\[DoubleStruckT]] -> haux[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]]], \[DoubleStruckA][\[DoubleStruckT]] -> T0aux[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], \[DoubleStruckA][\[DoubleStruckT]], k], \[DoubleStruckX][\[DoubleStruckT]] -> T0[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], k]};

DefaultSwitchingEvent[evnt_, opts:OptionsPattern[]] := Module[{a},
a = Events[OptionValue["DT"]];
a = Join[OptionValue["p"], a[[OptionValue["i"]]], OptionValue["a"]];
With[{e = a, o = OptionValue[WhenEvent]}, WhenEvent[evnt, e, o]]
];

AddSwitchingTimeEvents[T_, DT_:Automatic, opts:OptionsPattern[DefaultSwitchingEvent]] := Module[{t0, tf, p, a, k, n},
(* T contains indices in \[DoubleStruckC], with \[DoubleStruckC]\[LeftDoubleBracket]i\[RightDoubleBracket] being absolute time from t0 (= 0). *)
(* assumes T is in ascending order 0 <= T[i] <= T[i+1] *)
n = Length@T;
Table[
k = If[VectorQ[DT] && DT =!= {}, DT[[i]], 0];
(* final switching time derivative *)
tf = {\[DoubleStruckA][\[DoubleStruckT]] -> TFaux[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], \[DoubleStruckA][\[DoubleStruckT]], k], \[DoubleStruckX][\[DoubleStruckT]] -> TF[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], k]};
p = "p" -> tf;

(* start switching time derivative *)
t0 = {\[DoubleStruckA][\[DoubleStruckT]] -> T0aux[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], \[DoubleStruckA][\[DoubleStruckT]], k], \[DoubleStruckX][\[DoubleStruckT]] -> T0[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]], k]};
a = "a" -> Append[If[i < n, t0, {}], "RemoveEvent"];

(* final switching time? *)
k = "i" -> If[i < n, OptionValue[DefaultSwitchingEvent, "i"], {}];

(* create event *)
k = With[{j = T[[i]]}, DefaultSwitchingEvent[\[DoubleStruckT] - j == 0, p, a, k, WhenEvent -> Join[{"Priority" -> i}, OptionValue@WhenEvent], opts]];

(* allow for parameters in T *)
k /. \[DoubleStruckC][k_Integer] :> \[DoubleStruckC][[k]],
{i, n}
]
];

AddSwitchingEvent[evnt_, opts:OptionsPattern[]] := Module[{a},
a =DefaultSwitchingEvent[evnt, opts];
Last@AppendTo[e, a]
];

RemoveSwitchingEvent[form_:(_WhenEvent)] := e = DeleteCases[e, form];


(* ::Input::Initialization:: *)
(* let's make sure we are working with new code *)
Clear[T0, TF];


(* ::Input::Initialization:: *)
T0[m_, x_?VectorQ, c_?VectorQ, i_Integer] := Module[{X, C, F, Xt, Ct, Ft},
X = devec[x, nx];
C = devec[c, nc];
F = devec[rbd["f", m][X, C], nx];

Xt = devec[Join[X[[1]], F[[1]], ConstantArray[0.0, nx]], nx];
Ct = devec[Join[C[[1]], ConstantArray[0.0, 2nc]], nc];
Ft = devec[rbd["f", m][Xt, Ct], nx];

Sow[DT0[X, F, Ft, i], "x+"]
];

TF[m_, x_?VectorQ, c_?VectorQ, i_Integer] := Module[{X, C, F, Xt, Ct, Ft},
X = devec[x, nx];
C = devec[c, nc];
F = devec[rbd["f", m][X, C], nx];

Xt = devec[Join[X[[1]], F[[1]], ConstantArray[0.0, nx]], nx];
Ct = devec[Join[C[[1]], ConstantArray[0.0, 2nc]], nc];
Ft = devec[rbd["f", m][Xt, Ct], nx];

Sow[DTF[X, F, Ft, i], "x-"]
];


(* ::Input::Initialization:: *)
\[CurlyPhi]::ndsolve = "NDSolveValue failed: \n\tx = ``,\n\tc = ``,\n\tT = ``.";

Options[\[CurlyPhi]] = {"e" -> {}, "n" -> 0, "fs" -> {}, NDSolve -> {}, "t0" -> $MachineEpsilon, "tf" -> $MachineEpsilon};

\[CurlyPhi][m_, x_, c_, T_, opts:OptionsPattern[]] := Module[{eqn, o, t0, tf, a},
(* set time interval *)
{t0, tf} = If[VectorQ[T], T[[{1, -1}]], {0, T}];
(* MMA cannot detect events @ end points, push start and end times a little *)
t0 -= OptionValue["t0"];
tf += OptionValue["tf"];
a = aux0[m, x, c];

(* TODO: DELETE Check[...] and instead figure out why \[Tau] < 0 despite bounds *)
Check[
Block[{\[DoubleStruckX], \[DoubleStruckC], \[DoubleStruckT], \[DoubleStruckM], \[DoubleStruckA]},
(* eqns & events *)
eqn = {\[DoubleStruckX]'[\[DoubleStruckT]] == f[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]]], \[DoubleStruckA]'[\[DoubleStruckT]] == faux[\[DoubleStruckM][\[DoubleStruckT]], \[DoubleStruckX][\[DoubleStruckT]], \[DoubleStruckC][\[DoubleStruckT]]]};
eqn = Join[eqn, {\[DoubleStruckX][t0] == x, \[DoubleStruckC][t0] == c, \[DoubleStruckM][t0] == m, \[DoubleStruckA][t0] == a}, e, OptionValue["e"]];

(* get options: fixed step size? NDSolve opts *)
o = FixedStepSize[OptionValue["fs"], tf-t0, OptionValue["n"]];
o = Flatten@{o, OptionValue[NDSolve]};

(* solve ODE *)
o = Reap[Sow[m, "m"];Sow[c, "c"];Sow[x, "x-"];Sow[x, "x+"];Sow[a, "a-"];Sow[a, "a+"];
NDSolveValue[eqn, {\[DoubleStruckX], \[DoubleStruckC], \[DoubleStruckM], \[DoubleStruckA]}, {\[DoubleStruckT], t0, tf}, DiscreteVariables-> {\[DoubleStruckC], \[DoubleStruckM] \[Element] Keys@rbd["m"]}, o], _, Rule
];

(* should Throw@$Failed if NDSolveValue has errors *)

(* return trajectories and events *)
<|Thread[{"x[t]", "c[t]", "m[t]", "a[t]"} -> o[[1]]], Rest@o, "T" -> T|>
],
(* it's useful for debugging to make sure T >= 0 *)
Message[\[CurlyPhi]::ndsolve, x[[1;;nx]], c[[1;;nc]], T];
Throw@$Failed;
]
];


(* ::Input::Initialization:: *)
(* let's make sure we are working with new code *)
Clear[DT0, DTF];


(* ::Input::Initialization:: *)
DT0[x_, f_, fdot_, T_] := Module[{n, z},
(* T (an index) => switching time derivatives at s = t0 *)
z = x;
n = Length@z[[1]];
If[o >= 1 && T !=  0,
z[[2, All, T]] -= f[[1]];

If[o >= 2, 
Do[
z[[3, i, T, All]] = z[[3, i, All, T]] -= f[[2, i]];
z[[3, i, T, T]] -= f[[2, i, T]] + fdot[[2, i, 1]];, 
{i, n}
];
];
];

Flatten[z]
];

DTF[x_, f_, fdot_, T_] := Module[{n, z},
(* T (an index) => switching time derivatives at s = tf *)
(* or initial condition @ s = t0 for switching time derivatives at s = tf *)

(* f = {dx/dt, d/dc dx/dt, ... } *)
(* fdot = {dx/dt, d/dt dx/dt, ... } *)

z = x;
n = Length@z[[1]];
If[o >= 1 && T !=  0,
z[[2, All, T]] += f[[1]];

If[o >= 2, 
(* should this be df/dT dT/dc + f(T) d^2/dc^2(T)? *)
(* does this ignore f(T) d^2/dc^2(T) by assuming it's always zero? *)
(* by design it has been, but still... *)
Do[
z[[3, i, T, All]] = z[[3, i, All, T]] += f[[2, i]];
z[[3, i, T, T]] += f[[2, i, T]] + fdot[[2, i, 1]];, 
{i, n}
];
];
];

Flatten[z]
];


(* ::Input::Initialization:: *)
(* older version *)
(*DT0[m_, x_, c_, T_, A_] := Module[{z, F},
(* T (an index) => switching time derivatives at s = t0 *)
z = x;
If[o \[GreaterEqual] 1 && T \[NotEqual]  0,
F = devec[A["f", m][z, c], nx]\[LeftDoubleBracket]1\[RightDoubleBracket];
z\[LeftDoubleBracket]2, All, T\[RightDoubleBracket] -= F;

If[o \[GreaterEqual] 2, 
(* must have dx/dT set above before solving for Hessian *)
F = devec[A["f", m][z, c], nx]\[LeftDoubleBracket]2\[RightDoubleBracket];
Do[z\[LeftDoubleBracket]3, i, T, All\[RightDoubleBracket] = z\[LeftDoubleBracket]3, i, All, T\[RightDoubleBracket] -= F\[LeftDoubleBracket]i\[RightDoubleBracket];, {i, nx}];
];
];

Flatten[z]
];

DTF[m_, x_, c_, T_, A_] := Module[{z, F, zt, ct, Ft},
(* T (an index) => switching time derivatives at s = tf *)
(* or initial condition @ s = t0 for switching time derivatives at s = tf *)
z = x;
If[o \[GreaterEqual] 1 && T \[NotEqual]  0,
F = devec[A["f", m][z, c], nx](*\[LeftDoubleBracket]1\[RightDoubleBracket]*);
(*z\[LeftDoubleBracket]2, All, T\[RightDoubleBracket] += F;*)

If[o \[GreaterEqual] 2, 
(* must have dx/dT set above before solving for Hessian *)
(*F = devec[rbd["f", m][z, c], nx]\[LeftDoubleBracket]2\[RightDoubleBracket];*)

(* FIX BLAPPLY2 SO THAT IT USES ARGS AND NOT M *)

(* should this be df/dT dT/dc + f(T) d^2/dc^2(T)? *)
(* does this ignore f(T) d^2/dc^2(T) by assuming it's always zero? *)
(* by design it has been, but still... *)

zt = z;
zt\[LeftDoubleBracket]2\[RightDoubleBracket] = F\[LeftDoubleBracket]1\[RightDoubleBracket];
zt\[LeftDoubleBracket]3\[RightDoubleBracket] = 0F\[LeftDoubleBracket]1\[RightDoubleBracket];
ct = c;
ct\[LeftDoubleBracket]3\[RightDoubleBracket] = ct\[LeftDoubleBracket]2\[RightDoubleBracket] = 0ct\[LeftDoubleBracket]1\[RightDoubleBracket];
Ft = devec[A["f", m][zt, ct], nx];
(*Print["Ft: ", MatrixForm/@Ft];
Print["Ft[[2]]: ", Ft[[2]]];*)
Do[
z\[LeftDoubleBracket]3, i, T, All\[RightDoubleBracket] = z\[LeftDoubleBracket]3, i, All, T\[RightDoubleBracket] += F\[LeftDoubleBracket]2, i\[RightDoubleBracket];
z\[LeftDoubleBracket]3, i, T, T\[RightDoubleBracket] += F\[LeftDoubleBracket]2, i, T\[RightDoubleBracket] + Ft\[LeftDoubleBracket]2, i, 1\[RightDoubleBracket];, 
{i, nx}
];

(*Print["F: ", MatrixForm/@F];*)
];

z\[LeftDoubleBracket]2, All, T\[RightDoubleBracket] += F\[LeftDoubleBracket]1\[RightDoubleBracket]; (* order doesn't matter, this can be moved back up *)

Print["z: ", MatrixForm /@ z];
];

Flatten[z]
];*)


(* ::Input::Initialization:: *)
End[]
EndPackage[]
