(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["ContinuationMethods`", {"Options`"}]
Begin["`Private`"]

(* manifold *)
f = None;
ftol = 10^-5;
man = <||>;

(* tree depth *)
t = tmax = 0;

(* time *)
t0 = 0;
ttot = 0;
spn = 0;
mondata = {};

(* tangent space: orientation[U, U0] *)
orientation = orientcurve;

(* return data *)
cm = cmc;
cmdata = data;

(* neighborhood *)
k = 0; (* maximum dimension of manifold *)
nbrs = neighbors;

(* interface functions *)
Q = <||>;


(* ::Input::Initialization:: *)
ClearAll@tmon;
tmon[t_] := Module[{m, n, q, N, s},
m = Length@man;
q = Length@Q;

ttot = AbsoluteTime[] - t0;
spn = If[PossibleZeroQ[m], 0, ttot/m];

n = NumberForm[ttot, {4, 2}];
N = NumberForm[spn, {4,2}];
s = "tmon --- tree depth: `` |M|: `` |Q|: `` t: ``\[ThinSpace]s t/|M|: ``\[ThinSpace]s/pt";
StringTemplate[s][t, m, q, n, N]
];

tmon[t0_, k_, man_, Q_, OptionsPattern[]] := If[t0 == 0, PrintTemporary@Dynamic[tmon[t]]];

rootmon[d_] := Module[{f, \[Phi], ftol, abort, r, stop},
{f, ftol, abort, r} = d;
If[KeyExistsQ[f, "cmroot"],
\[Phi] = f["cmroot", "\[Phi]"][[1]];
f = f["cmroot", "f"][[1, 1]];
stop = Abs[f] < ftol; (* should be norm, but crashes *)
r = If[r, "root", "minimizer"];
If[stop,
StringTemplate["root --- f: `` [\[Phi]: ``] <--- ``!"][f, \[Phi], r],
(* else *)
StringTemplate["root --- f: `` [\[Phi]: ``] --- searching for ``."][f, \[Phi], r]
],
(* else *)
"no cmroot data"
]
];

rootmon[t_, k_, man_, Q_, opts:OptionsPattern[cmroot]] := Module[{},
tmon[t, k, man, Q, opts];
mondata = {man[k], OptionValue["ftol"], OptionValue@Abort, OptionValue@Root};
If[t == 0, PrintTemporary@Dynamic[rootmon[mondata]];
];
];

plotmon[t_] := Module[{p, n},
p = Values@KeySelect[man[[ All, "c", 1, mondata[[1]]]], NonNegative[#[[1]]]&];
n = Values@KeySelect[man[[ All, "c", 1, mondata[[1]]]], NonPositive[#[[1]]]&];
If[Length[mondata[[1]]] <= 2, ListPlot, ListPointPlot3D][{p, n}, mondata[[2]], PlotRange -> All]
];

plotmon[data_, t0_, k_, man_, Q_, OptionsPattern[]] := If[t0 == 0, 
mondata = data;
tmon[t, k, man, Q, opts];
PrintTemporary@Dynamic[tmon[t]];
PrintTemporary@Dynamic[plotmon[t]]
];


(* ::Input::Initialization:: *)
Clear@neighbors; (* original signature is more specific *)
(* add Positive|Negative|All|Ignore later *)
neighbors[Man_, z0_, k_] := neighbors[dim[Man, z0], k];

neighbors[d_, k_] := Module[{m, n, I, i},
(* sort dimensions *)
{m, n} = MinMax[{d, k}];
(* handle 0-dim *)
I = If[n > 0, IdentityMatrix[n], {}];
(* {set of directions for old manifold, set of new nodes} *)
m = I[[1;;m, 1;;m]];
i = Range[k+1, n];
n = I[[i]];
<|"+" -> m, "-" -> -m, "b+" -> n, "b-" -> -n, "d" -> i|>
];

initnbrs[d_] := Module[{a},
a = <|Positive -> {"+", "b+", "d"}, Negative -> {"-", "b-", "d"}, IgnoreCase -> {"+", "-"}|>;
Switch[d, 
All|Automatic, neighbors, 
Alternatives@@Keys@a, With[{i = a[d]}, neighbors[##][[i]]&], 
Root, <|"+"->{{1}}|>&, 
_, d
]
]


(* ::Input::Initialization:: *)
Clear@Man0;  (* original signature is more specific *)


(* ::Input::Initialization:: *)
Man0::iso = "Initial point is isolated.";
Man0[c0_, h_, opts:OptionsPattern[]] := Module[{n, m, z0},
{m, n} = Dimensions[f[c0][[2]]];
k = Max[n - m, 1]; (* assume 0-dim is actually a bifurcation *)
z0 = embed[0];
m = "c" -> {c0, ConstantArray[0.0, {n, k}]};
m = <|z0 -> <|m, "h" ->  h, "d" -> Range@k|>|>;
m = cm[m, z0, z0, MergeOpts[{"corrector" -> "max" -> 0, opts}]];
If[dim[m["c"]] == 0,
Message[Man0::iso];
Throw@$Failed;
];

man[z0] = Association[m, "man0" -> <|"nfev" -> 1|>];
mon[t, z0, man, Q, opts];

{{z0}}
];

Man0[A_Association, h_, opts:OptionsPattern[]] := Module[{n, m, z0, c0},
(* here we assume A is of same form as output of Man *)
z0 = Keys@A;
k = Max[Length /@ z0, 1]; (* assume 0-dim is actually a bifurcation *)
man = A;
mon[t, z0, man, Q, opts];
{z0}
];


(* ::Input::Initialization:: *)
Mani::bif = "Detected a `1`-dimensional tangent space.  Increasing max dimension at a point from `2` to `1`.";
Mani[z0_, opts:OptionsPattern[]] := Module[{a, N, d, z, i, f},
If[man[z0] =!= $Failed, 
(* generate neighborhood *)
N = nbrs[man, z0, k];

(* update k *)
d = dim[man, z0];
If[d > k,
Message[Mani::bif, d, k];
Return[{}];
k = d;
man[z0, "d"] = Join[man[z0, "d"], Lookup[N, "d", {}]];
man = KeyMap[embed, man];
f = Map[embed];
man[[All, "rf"]] = Values@f[man[[All, "rf"]]];
Q = f[Q];
];

(* compute new points *)
a = embed[z0];
f = embed[man, a, #]&;
z = Join@@Lookup[N, {"+", "-", "b+", "b-"}, {}];
z = Select[f /@ z, KeyFreeQ[man, #]&];
Do[
man[i] = Catch[cm[man, i, a, opts]];
mon[t, i, man, Q, opts];, 
{i, z}
];

z,
(* else *)
{}
]
];


(* ::Input::Initialization:: *)
Options[Man] := {
(* queue management *)
"s" -> (#&), (* selector (default is select all) *)
"a" -> (Join[#1, Sequence@@#2]&), 
"r" -> (Drop[#1, Length@#2]&), 
"m" -> Function[{z0, o}, Map[Mani[#, o]&, z0]],
"n" -> neighbors,  (* neighbors = All|Positive|Negative|Ignore|func *)
Monitor -> tmon, 

(* tangent space *)
(*"k" \[Rule] 2,(* increases in dimensions are expensive operations *)*)
"o" -> orientcurve, 

(* continuation scheme *)
Method -> cmc, 
"cmi" -> {}, 
"cm0" -> {}, 
"cm" -> {}, 
"cmdata" -> data
};

Man[root_, c0_, h_, N_, opts:OptionsPattern[]] := Module[{sel, add, rmv, mani, z0, z, Z0, o},
(* set up manifold and continuation method *)
man = <||>;
f = root;
cm = OptionValue[Method];
cmdata = OptionValue["cmdata"];

(* set up tangent space *)
(*k = OptionValue["k"];*) (* maybe save for later *)
orientation = OptionValue["o"];

(* setup neighborhood *)
nbrs = initnbrs[OptionValue["n"]];

(* monitor, called after a point is found *)
mon = OptionValue[Monitor];

(* depth of tree *)
t = 0;
tmax = N;

(* time *)
ttot = 0;
nps = 0;
t0 = AbsoluteTime[];

(* Q functions *)
Q = {};
sel = OptionValue["s"];
mani = OptionValue["m"];
add = OptionValue["a"];
rmv = OptionValue["r"];

CheckAbort[
(* add first point *)
o = Flatten[{OptionValue["cm0"], OptionValue["cm"]}, 1];
Z0 = Man0[c0, h, o];
Q = add[Q, Z0];

o = Flatten[{OptionValue["cmi"], OptionValue["cm"]}, 1];
While[t < tmax && Length@Q > 0,
t++;
z0 = sel[Q];
z = mani[z0, o];

Q = add[Q, z];
Q = rmv[Q, z0];
];

Print@tmon[t];
man,

Print@tmon[t];
man
]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]



