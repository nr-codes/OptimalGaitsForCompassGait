(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
MultiparameterContinuationMethods.nb: An implementation of various continuation methods.
Copyright (C) 2017 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["ContinuationMethods`", {"Options`"}]

Begin["`Private`"]


(* ::Input::Initialization:: *)
step[R_] := If[Length@R > 2, halley[R], newton[R]];

step[c_, R_, OptionsPattern[corrector]] := Module[{dc, b},
dc = step[R];
(* projected step *)
b = OptionValue["b"];
If[b =!= {}, -c + ComputeBounds[c+dc, b, OptionValue@"bopts"], dc]
];

newton[R_] := -LeastSquares[R[[2]], R[[1]]];

halley[R_] := Module[{a, b},
a = newton[R];
b = LeastSquares[R[[2]], R[[3]] . a . a];
If[PossibleZeroQ@Norm@b, b, a^2 / (a + b / 2)]
];


(* ::Input::Initialization:: *)
correctormsg = StringTemplate["    corrector (``/``) --- err: `` step: `` h: ``"];


(* ::Input::Initialization:: *)
correctormon[i_, normr_, normdc_, h_, opts:OptionsPattern[corrector]] := Print[correctormsg[i, OptionValue["max"], ScientificForm[normr, 5], ScientificForm[normdc, 5], NumberForm[h, {1,3}]]];


(* ::Input::Initialization:: *)
Options[corrector] = {
Print -> False, 

"ftol" -> 10.0^-5,(* reject if corrector is really bad *)
"rtol" -> 10.0^-12, (* stop if step size is really small *)
"atol" -> 10.0^-8,(* stop if corrector is really good *)
"dtol" -> 10.0, (* stop if step size is really big *)

"max" -> 10, (* max number of corrector iterations *)

"f+" -> (#2&), (* => f[c, R, C0, h] && f[c, R, C0, h, Raug] *)

"b" -> {}, (* simple bounds on input {i \[Rule] {l, u} => l \[LessEqual] c\[LeftDoubleBracket]i\[RightDoubleBracket] u \[LessEqual] u} *)
"bopts" -> False (* print summary of bounds *)
};

corrector::cvmit = "Failed to converge within `3` iterations; starting from `1` the final error was `2`.";

corrector::step = "The norm of the step size for `1` is `2` (> `3`); the search is likely to diverge.";


(* ::Input::Initialization:: *)
corrector[c0_, h_, C0_, opts:OptionsPattern[]] := Module[{R, c, dc, C, a, b, rtol, atol, ftol, dtol, max, P, ndc, nr, nfev},
rtol = OptionValue["rtol"];
atol = OptionValue["atol"];
ftol = OptionValue["ftol"];
dtol = OptionValue["dtol"];

a = OptionValue["f+"];
b = OptionValue["b"];
max = OptionValue["max"];
P = OptionValue[Print];

c = c0; (* should we compute bounds here? *)
C = C0; (* we want to project down from prediction *)
C[[1]] = c0;

R = SparseArray /@ a[c, f[c], C, h];
nr = Norm[R[[1]]];
nfev = 1;
Do[
(* take a step towards root *)
dc = step[c, R, opts];
ndc = Norm[dc];

If[Mod[i, P] === 0, correctormon[i, nr, ndc, h, opts];];

If[ndc < rtol || nr < atol, Break[];];
If[ndc > dtol,
Message[corrector::step, c0, ndc, dtol];
Throw[$Failed];
];

c = c + dc;

R = SparseArray /@ a[c, f[c], C, h, R];
nr = Norm[R[[1]]];
nfev++;,
{i, max}
];

If[nr > ftol, 
Message[corrector::cvmit, c0, nr, max];
Throw[$Failed];
];

{c, R, nfev}
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]



