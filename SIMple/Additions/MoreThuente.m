(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
MoreThuente.nb: An implementation of various line search methods.
Copyright (C) 2021 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["ContinuationMethods`"]
Begin["`Private`"]


(* ::Input::Initialization:: *)
MoreThuente::args = "Improper input parameters: ``";

MoreThuente::rounding = "Rounding errors prevent further progress.  There may not be a step which satisfies the sufficient decrease and curvature conditions.  Tolerances may be too small.";

MoreThuente::stpmax = "The step is at the upper bound stpmax.";

MoreThuente::stpmin = "The step is at the lower bound stpmin.";

MoreThuente::maxfev = "Number of calls to fcn has reached maxfev.";

MoreThuente::xtol = "Relative width of the interval of uncertainty is at most xtol.";


(* ::Input::Initialization:: *)
Options[MoreThuente] = {
"stp" -> 1.0, 
"ftol" -> 10.0^-4, 
"gtol" ->0.9, 
"xtol" -> 10.0^-10,
"stpmin" -> 10.0^-10, 
"stpmax" -> 5, 
"maxfev" -> 10,

"p5" -> 0.5,
"p66" -> 0.66,
"xtrapf" -> 4.0
};


(* ::Input::Initialization:: *)
MoreThuente[data_] := Module[{stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev},

{stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev}= data[[1;;13]];
(* compute step *)
If[brackt, 
stmin = Min[stx, sty];
stmax = Max[stx, sty];,
(* else *)
stmin = stx;
stmax = stp + xtrapf (stp - stx);
];

stp = Max[stp, stpmin];
stp = Min[stp, stpmax];

If[(brackt && (stp <= stmin || stp >= stmax)) || nfev >= maxfev - 1 || infoc == 0 || (brackt && stmax - stmin <= xtol  stmax), 
stp = stx;
];

{stp, stmin, stmax}
];


(* ::Input::Initialization:: *)
MoreThuente[fg0_, s0_, {}, OptionsPattern[]] := Module[{stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev, width, width1, finit, fx, fy, ftol, dginit, dgx, dgy, dgtest, gtol, stage1, p66, p5, (* <- data | locals -> *) f, g, n, info, data, d},

{f, g} = fg0[[1;;2]];
n = Length@s0;

stp = OptionValue["stp"];
ftol = OptionValue["ftol"];
gtol = OptionValue["gtol"];
xtol = OptionValue["xtol"];
stpmin = OptionValue["stpmin"];
stpmax = OptionValue["stpmax"];
maxfev = OptionValue["maxfev"];

p5 = OptionValue["p5"];
p66 = OptionValue["p66"];
xtrapf = OptionValue["xtrapf"];

info = 0;
infoc = 1;
nfev = 0;

If[n <= 0 || stp <= 0 || ftol < 0 || gtol < 0 || xtol < 0 || stpmin < 0  || stpmax < stpmin || maxfev <= 0, 
Message[MoreThuente::args, "Tolerances or step bounds invalid."];
Throw@$Failed;
];

dginit =  g.s0;
If[dginit >= 0, 
Message[MoreThuente::args, "Not a descent direction."];
Throw@$Failed;
];

(* local variables *)
brackt = False;
stage1 = True;
finit = f;
dgtest = ftol dginit;
width = stpmax - stpmin;
width1 = 2 width;

(* best so far *)
stx = 0;
fx = finit;
dgx = dginit;
(* limit point *)
sty = 0;
fy = finit;
dgy = dginit;

data = {stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev, width, width1, finit, fx, fy, ftol, dginit, dgx, dgy, dgtest, gtol, stage1, p66, p5};

{stp, stmin, stmax} = MoreThuente[data];
d = stp s0;
Join[{d, info, stp, stmin, stmax}, data[[4;;]]]
];


(* ::Input::Initialization:: *)
MoreThuente[fg_, s0_, data_, OptionsPattern[]] := Module[{stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev, width, width1, finit, fx, fy, ftol, dginit, dgx, dgy, dgtest, gtol, stage1, p66, p5, (* <- data | locals -> *) f, g, dg, ftest1, info, fm, fxm, fym, dgm, dgxm, dgym, d},

{stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev, width, width1, finit, fx, fy, ftol, dginit, dgx, dgy, dgtest, gtol, stage1, p66, p5} = data[[3;;]];

{f, g} = fg[[1;;2]];
dg = g.s0;
ftest1 = finit + stp dgtest;
info = 0; (* info = 0 => make another fcn call *)
nfev = nfev + 1;

(* test for convergence *)
If[(brackt && (stp <= stmin || stp >= stmax)) || infoc == 0, 
(* Rounding errors prevent further progress. *)
Message[MoreThuente::rounding];
info = 6;
];

If[stp == stpmax && f <= ftest1 && dg <= dgtest,
(* The step is at the upper bound stpmax. *)
Message[MoreThuente::stpmax];
info = 5;
];

If[stp == stpmin && (f > ftest1 || dg >= dgtest), 
(* The step is at the lower bound stpmin. *)
Message[MoreThuente::stpmin];
info = 4;
];

If[nfev >= maxfev, 
(* Number of calls to fcn has reached maxfev. *)
Message[MoreThuente::maxfev];
info = 3;
];

If[brackt && stmax - stmin <= xtol stmax,
(* Relative width of the interval of uncertainty is at most xtol. *)
Message[MoreThuente::xtol];
info = 2;
];

If[f <= ftest1 && Abs[dg] <= gtol (-dginit),
(* The sufficient decrease condition and the directional *)
(* derivative condition hold. (Armijo and Strong Wolfe conditions) *)
info = 1;
];

(* check for termination *)
If[info == 0,
(* find a step where f \[LessEqual] 0 and dg \[GreaterEqual] 0 *)
If[stage1 && f <= ftest1 && dg >= Min[ftol, gtol] dginit,
stage1 = False;
];

If[stage1 && f <= fx && f > ftest1,
fm=f-stp dgtest;
fxm=fx-stx dgtest;
fym=fy-sty dgtest;
dgm=dg-dgtest;
dgxm=dgx-dgtest;
dgym=dgy-dgtest;

{stx,fxm,dgxm,sty,fym,dgym,stp,fm,dgm,brackt,infoc} = MoreThuenteStep[stx,fxm,dgxm,sty,fym,dgym,stp,fm,dgm, brackt,stmin,stmax];

(* update params *)
fx=fxm+stx*dgtest;
fy=fym+sty*dgtest;
dgx=dgxm+dgtest;
dgy=dgym+dgtest;,

(* else *)
{stx,fx,dgx,sty,fy,dgy,stp,f,dg,brackt,infoc} =MoreThuenteStep[stx,fx,dgx,sty,fy,dgy,stp,f,dg,brackt,stmin,stmax];
];

(* shrink interval *)
If[brackt, 
If[Abs[sty-stx]>=p66*width1,
stp=stx+p5*(sty-stx);
];
width1=width;
width=Abs[sty-stx];
];

d = {stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev};
{stp, stmin, stmax} = MoreThuente[d];
];

d = stp s0;

{d, info, stp, stmin, stmax, stpmin, stpmax, stx, sty, brackt, xtrapf, xtol, infoc, nfev, maxfev, width, width1, finit, fx, fy, ftol, dginit, dgx, dgy, dgtest, gtol, stage1, p66, p5}
];


(* ::Input::Initialization:: *)
MoreThuenteStep::args = "Improper input parameters";


(* ::Input::Initialization:: *)
MoreThuenteStep[stx0_, fx0_, dx0_, sty0_, fy0_, dy0_, stp0_, fp0_, dp0_, brackt0_, stpmin0_, stpmax0_] := Module[{p66, info, sgnd, bound, theta, s, gamma, p, q, r, stpc, stpq, stpf, st, stx, fx, dx, sty, fy, dy, stp, fp, dp, brackt, stpmin, stpmax},

{stx, fx, dx, sty, fy, dy, stp, fp, dp, brackt, stpmin, stpmax} = {stx0, fx0,  dx0, sty0, fy0, dy0, stp0, fp0, dp0, brackt0, stpmin0, stpmax0};

p66 = 0.66;
info = 0;

If[(brackt && (stp <= Min[stx, sty] || stp >= Max[stx, sty])) || dx (stp - stx) >= 0 || stpmax < stpmin,
Message[MoreThuenteStep::args];
(*Return[{stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,info}];*)
Throw@$Failed;
];

sgnd = dp (dx/Abs[dx]);

Which[
(* case 1: bracketed choose btw cubic and avg(cubic, quad) *)
fp > fx,
info = 1;
bound = True;
theta=3(fx-fp)/(stp-stx)+dx+dp;
s = Norm[{theta, dx, dp}, Infinity];
gamma = s Sqrt[ (theta/s)^2 - (dx/s) (dp/s)];
If[stp < stx, gamma = -gamma;];
p = (gamma - dx) + theta;
q = ((gamma -dx) + gamma) + dp;
r = p/q;
stpc = stx + r (stp - stx);
stpq = stx + ((dx/((fx-fp)/(stp -stx)+dx))/2) (stp- stx);
If[Abs[stpc-stx] < Abs[stpq-stx], 
stpf = stpc;, 
(* else *)
stpf = stpc + (stpq -stpc)/2;
];
brackt = True;,
(* case 2: lower f bracketed choose btw cubic and quad *)
sgnd < 0,
info = 2;
bound = False;
theta = 3 (fx - fp)/(stp -stx) + dx + dp;
s = Norm[{theta, dx, dp}, Infinity];
gamma = s Sqrt[ (theta/s)^2 - (dx/s) (dp/s)];
If[stp > stx, gamma = -gamma;];
p = (gamma - dp) + theta;
q = ((gamma - dp) + gamma) + dx;
r = p/q;
stpc = stp + r (stx - stp);
stpq=stp+(dp/(dp-dx))(stx-stp);
If[Abs[stpc-stp]>Abs[stpq-stp], 
stpf = stpc;, 
(* else *)
stpf = stpq;
];
brackt = True;,
(* case 3: lower f not bracketed *)
Abs[dp] < Abs[dx],
info=3;
bound=True;
theta=3(fx-fp)/(stp-stx)+dx+dp;s=Norm[{theta,dx,dp},Infinity];
(* gamma = 0 if cubic does not tend towards \[Infinity] *)
gamma=s Sqrt[Max[0,(theta/s)^2-(dx/s)(dp/s)]];If[stp>stx, gamma=-gamma;];
p=(gamma-dp)+theta;
q=(gamma+(dx-dp))+gamma;
r=p/q;
Which[
r<0.0 && gamma != 0,
stpc=stp+r(stx-stp);,
(* else if *)
stp>stx,
stpc=stpmax;,
(* else *)
True,
stpc=stpmin;
];
stpq=stp+(dp/(dp-dx))(stx-stp);
If[brackt,
If[Abs[stp-stpc]<Abs[stp-stpq],
stpf=stpc;,
(* else *)
stpf=stpq;
];,
(* else *)
If[Abs[stp-stpc]>Abs[stp-stpq],
stpf=stpc;,
(* else *)
stpf=stpq;
];
];,
(* case 4: lower f not bracketed g not decreasing *)
True,
info = 4;
bound=False;
Which[
brackt,
theta=3(fp-fy)/(sty-stp)+dy+dp;s=Norm[{theta,dy,dp},Infinity];
gamma=s Sqrt[(theta/s)^2-(dy/s)(dp/s)];If[stp>sty, gamma=-gamma;];p=(gamma-dp)+theta;q=((gamma-dp)+gamma)+dy;r=p/q;stpc=stp+r*(sty-stp);stpf=stpc;,
(* else if *)
stp>stx,
stpf=stpmax;,
(* else *)
True,
stpf=stpmin;
];
];

(* update bounds *)
If[fp > fx,
sty = stp;
fy=fp;
dy=dp;,
(* else *)
If[sgnd<0.0,
sty=stx;
fy=fx;
dy=dx;
];
stx=stp;
fx=fp;
dx=dp;
];

(* compute new safe-guarded step *)
stpf=Min[stpmax,stpf];
stpf=Max[stpmin,stpf];
stp=stpf;
If[brackt && bound,
If[sty>stx,
stp=Min[stx+p66(sty-stx),stp];,
(* else *)
stp=Max[stx+p66(sty-stx),stp];
];
];

{stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,info}
];


(* ::Input::Initialization:: *)
MoreThuenteDriver[fcn_, x0_, fg0_, s0_, opts:OptionsPattern[Armijo]] := Module[{d, info, stp, data, fg, nfev},
info = 0;
nfev = 0;
data = {};
fg = fg0;

While[True,
data = MoreThuente[fg, s0, data, opts];
{d, info, stp} = data[[1;;3]];
If[info != 0, Break[]];
fg = fcn[x0 + d][[1;;2]];
nfev++;
];

{x0 + d,fg,stp,info,nfev}
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]



