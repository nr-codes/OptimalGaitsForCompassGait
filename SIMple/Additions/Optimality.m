(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["BipedalLocomotion`", {"GlobalVariables`", "RigidBodyDynamics`", "HybridDynamics`", "BipedalLocomotion`Model`"}]

Begin["`Private`"]


(* ::Input::Initialization:: *)
Options[FirstOrderOptimalityCondition] = {"i" -> All};


(* ::Input::Initialization:: *)
FirstOrderOptimalityCondition[F_, M_, True, OptionsPattern[]] := Module[{n, m, i, \[Lambda], R, OC, d\[Lambda]dR},
R = M["R"];
{n, m} = Dimensions@R[[2]];
i = OptionValue["i"];
(* df/dc + \[Lambda]\[Transpose].dM/dc and d/dc (df/dc + \[Lambda]\[Transpose].dM/dc)*)
\[Lambda] = M["c"][[1, All, i[[1;;n]]]];
d\[Lambda]dR = 0.5(R[[2]]\[Transpose] . \[Lambda][[2]]+(R[[2]]\[Transpose] . \[Lambda][[2]])\[Transpose]);
OC = {F[[2, 1]] + \[Lambda][[1]] . R[[2]], F[[3, 1]] + \[Lambda][[1]] . R[[3]] + d\[Lambda]dR};
(* hold unused multipliers fixed at zero *)
\[Lambda] = M["c"][[1, All, i[[n + 1;;]]]];
(* not all of df/dc is relevant; only return non-Lagrangian parameters *)
i = If[# < 0, m + # + 1, #]& /@ i;
i = Complement[Range@m, i];
MapThread[Join, {\[Lambda][[1;;2]], OC[[All, i]]}]
];


(* ::Input::Initialization:: *)
FirstOrderOptimalityCondition::bif = "A bifurcation point at `1` has (potentially) been detected: `2`.";

FirstOrderOptimalityCondition::ns = "Isolated point.";

FirstOrderOptimalityCondition[F_, M_, False, OptionsPattern[]] := Module[{R, C, i, n, k, A, B, m, r, U},
i = OptionValue["i"];

R = M["R"];
R[[2]] = R[[2, All, i]];
R[[3]] = R[[3, All, i]];

(* compute {dc/ds, d/dc dc/ds} (n x k, n x k x n) *)
C = NullSpace[R[[2]]]; (* no transpose! *)
If[C === {}, 
Message[FirstOrderOptimalityCondition::ns];
Throw@$Failed;
];

{k, n} = Dimensions@C;

(*r = n - k;
U = SingularValueDecomposition[R\[LeftDoubleBracket]2\[RightDoubleBracket]]\[LeftDoubleBracket]1, All, 1;;r\[RightDoubleBracket];
U = PseudoInverse[U];
Print[r, " UR2: ", MatrixForm@Chop[U.R\[LeftDoubleBracket]2\[RightDoubleBracket], 10^-5]];*)

m = Length@R[[2]];
If[k !=  n - m, 
Message[FirstOrderOptimalityCondition::bif, Normal@M["p"], MatrixForm@C];
Throw@$Failed;
];

(*A = Join[U.R\[LeftDoubleBracket]2\[RightDoubleBracket], C]; (* this is bifurcation test function *)
B = Join[-U.(C.R\[LeftDoubleBracket]3\[RightDoubleBracket]\[Transpose])\[Transpose],  ConstantArray[0.0, {k, k, n}]];*)

A = Join[R[[2]], C]; (* this is bifurcation test function *)
B = Join[-(C . R[[3]]\[Transpose])\[Transpose],  ConstantArray[0.0, {k, k, n}]];

B = ArrayReshape[B, {n, k n}];
C = {C\[Transpose], ArrayReshape[LinearSolve[A, B], {n, k, n}]};

(* compute {df/ds, d/dc df/ds} (p x k, p x k x n) *)
A = F[[2;;3, 1, i]];
{A[[1]] . C[[1]], C[[1]]\[Transpose] . A[[2]] + A[[1]] . C[[2]]}
];

(*FirstOrderOptimalityCondition[F_, M_, False, OptionsPattern[]] := Module[{R, C, i},
i = OptionValue["i"];

R = M["R"];
R\[LeftDoubleBracket]2\[RightDoubleBracket] = R\[LeftDoubleBracket]2, All, i\[RightDoubleBracket];
R\[LeftDoubleBracket]3\[RightDoubleBracket] = R\[LeftDoubleBracket]3, All, i\[RightDoubleBracket];

(* compute {dc/ds, d/dc dc/ds (or d^2c/ds^2)} *)
C = NullSpace[R\[LeftDoubleBracket]2\[RightDoubleBracket]];
C = {C, -PseudoInverse[R\[LeftDoubleBracket]2\[RightDoubleBracket]].((C.R\[LeftDoubleBracket]3\[RightDoubleBracket]\[Transpose])\[Transpose])};
If[OptionValue["s"],
C\[LeftDoubleBracket]2\[RightDoubleBracket] = C\[LeftDoubleBracket]2\[RightDoubleBracket].C\[LeftDoubleBracket]1\[RightDoubleBracket];
(* {df/ds, d^2f/ds^2} *)
{F\[LeftDoubleBracket]2, 1, i\[RightDoubleBracket].C\[LeftDoubleBracket]1\[RightDoubleBracket]\[Transpose], C\[LeftDoubleBracket]1\[RightDoubleBracket].F\[LeftDoubleBracket]3, 1, i\[RightDoubleBracket].C\[LeftDoubleBracket]1\[RightDoubleBracket]\[Transpose] + F\[LeftDoubleBracket]2, 1, i\[RightDoubleBracket].C\[LeftDoubleBracket]2\[RightDoubleBracket]},
(* else *)
(* {df/ds, d/dc df/ds} *)
{F\[LeftDoubleBracket]2, 1, i\[RightDoubleBracket].C\[LeftDoubleBracket]1\[RightDoubleBracket]\[Transpose], C\[LeftDoubleBracket]1\[RightDoubleBracket].F\[LeftDoubleBracket]3, 1, i\[RightDoubleBracket] + F\[LeftDoubleBracket]2, 1, i\[RightDoubleBracket].C\[LeftDoubleBracket]2\[RightDoubleBracket]}
]
];*)


(* ::Input::Initialization:: *)
(*FArcLength[F_, R_] := Module[{n, k, C, A, B},
C = NullSpace[R\[LeftDoubleBracket]2\[RightDoubleBracket]]\[Transpose];
{n, k} = Dimensions[C];

(* solve for d^2c/ds^2 *)
A = Join[R\[LeftDoubleBracket]2\[RightDoubleBracket], C\[Transpose]];
B = Join[-(C\[Transpose].R\[LeftDoubleBracket]3\[RightDoubleBracket]\[Transpose])\[Transpose].C, ConstantArray[0.0, {k, k, k}]];
B = LinearSolve[A, ArrayReshape[B, {n, k^2}]];
C = {{}, C, ArrayReshape[B, {n, k, k}]};

{F\[LeftDoubleBracket]1\[RightDoubleBracket], F\[LeftDoubleBracket]2\[RightDoubleBracket].C\[LeftDoubleBracket]2\[RightDoubleBracket], (C\[LeftDoubleBracket]2\[RightDoubleBracket]\[Transpose].F\[LeftDoubleBracket]3\[RightDoubleBracket]\[Transpose])\[Transpose].C\[LeftDoubleBracket]2\[RightDoubleBracket] + F\[LeftDoubleBracket]2\[RightDoubleBracket].C\[LeftDoubleBracket]3\[RightDoubleBracket]}
];*)

FArcLength[M_] := Module[{n, k, m, C, R, F, A, B},
(* compute {dc/ds, d^2c/ds^2} (n x k, n x k x k) *)
R = M["F", "R"];
F = M["F", "f"];
C = NullSpace[R[[2]]]; (* no transpose! *)
If[C === {}, 
Message[FirstOrderOptimalityCondition::ns];
Throw@$Failed;
];

{k, n} = Dimensions@C;

m = Length@R[[2]];
If[k !=  n - m, 
Message[FirstOrderOptimalityCondition::bif, Normal@M["p"], MatrixForm@C];
Throw@$Failed;
];

(* solve for d^2c/ds^2 *)
C = C\[Transpose];
A = Join[R[[2]], C\[Transpose]];
B = Join[-(C\[Transpose] . R[[3]]\[Transpose])\[Transpose] . C, ConstantArray[0.0, {k, k, k}]];
B = LinearSolve[A, ArrayReshape[B, {n, k^2}]];
B = ArrayReshape[B, {n, k, k}];

C = {M["p"], C, B};
{F[[1]], F[[2]] . C[[2]], (C[[2]]\[Transpose] . F[[3]]\[Transpose])\[Transpose] . C[[2]] + F[[2]] . C[[3]]}
];

Fsc[F_, R_] := Module[{n, k, C, A, B},
C = NullSpace[R[[2]]]; (* no transpose! *)
{k, n} = Dimensions@C;

A = Join[R[[2]], C]; (* this is bifurcation test function *)
B = Join[-(C . R[[3]]\[Transpose])\[Transpose],  ConstantArray[0.0, {k, k, n}]];
B = ArrayReshape[B, {n, k n}];
C = {{}, C\[Transpose], ArrayReshape[LinearSolve[A, B], {n, k, n}]};

(* compute {df/ds, d/dc df/ds} (p x k, p x k x n) *)
{F[[1]], F[[2]] . C[[2]], (C[[2]]\[Transpose] . F[[3]]\[Transpose])\[Transpose] + F[[2]] . C[[3]]}
];

Fss[F_, R_] := Module[{n, k, C, A, B},
C = NullSpace[R[[2]]]\[Transpose];
{n, k} = Dimensions[C];

(* solve for d^2c/ds^2 *)
A = Join[R[[2]], C\[Transpose]];
B = Join[-(C\[Transpose] . R[[3]]\[Transpose])\[Transpose] . C, ConstantArray[0.0, {k, k, k}]];
B = LinearSolve[A, ArrayReshape[B, {n, k^2}]];
C = {{}, C, ArrayReshape[B, {n, k, k}]};

{F[[1]], F[[2]] . C[[2]], (C[[2]]\[Transpose] . F[[3]]\[Transpose])\[Transpose] . C[[2]] + F[[2]] . C[[3]]}
];


(* ::Input::Initialization:: *)
OptimalityConstraints[F_, M_, C___List, \[Lambda]_?BooleanQ, i_] := Module[{L, O},
L = M;
L["R"] = MapThread[Join, Normal@{L["R"], C}];
O = FirstOrderOptimalityCondition[F, L, \[Lambda], "i" -> i];
L["F"] = <|"f" -> F, "o" -> O, "R" -> L["R"](*, "s" \[Rule] FArcLength[F, L]*)|>;
L["R"] = MapThread[Join, Normal@{L["R"][[1;;2]], O}];
L
];

OptimalityConstraints[f_, bnds_, M_, C___List, \[Lambda]_?BooleanQ, i_, opts:OptionsPattern[BLApplyBounds2]] := Module[{F},
F = SparseArray /@ BLApplyBounds2[M, f, bnds, opts];
OptimalityConstraints[F, M, C, \[Lambda], i]
];

(* update work to give a scaling matrix W to penalize +'ve/-'ve work *)
EffortOptimalityConstraints[M_, C___List, \[Lambda]_?BooleanQ, i_, opts:OptionsPattern[BLApplyBounds2]] := OptimalityConstraints["cost", {3 -> {-\[Infinity], -\[Infinity]}}, M, C, \[Lambda], i, opts];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
