(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*
ContinuationMethods.nb: An implementation of various continuation methods.
Copyright (C) 2014 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["ContinuationMethods`"]

Begin["`Private`"]


(* ::Input::Initialization:: *)
Options[cmc] = {"corrector" -> {}, "cmdata" -> {}, Print -> False};
cmc[Man_, z_, z0_, OptionsPattern[]] := Module[{h, C0, k, d, c, o, R, A, nfev},
h = Man[z0, "h"];
C0 = Man[z0, "c"];
k = dim[C0];

(* prediction *)
d = h project[Man, z, z0];
c = predictor[C0, d];

(* correction *)
o = OptionValue["corrector"];
{c, R, nfev} = corrector[c, d, C0, "f+" -> augment, o];

(* split augmented root *)
{R, A} = {R[[All, 1;;-k-1]], R[[All, -k;;-1]]};

(* return info *)
o = OptionValue@"cmdata";
A = <|"cmc" -> <|(*"R" \[Rule] R, "A" \[Rule] A,*) "nfev" -> nfev|>|>;
cmdata[Man, z, z0, c, R, A, o]
];


(* ::Input::Initialization:: *)
cmroot::ls = "Could not satisfy sufficient decrease condition for `` after `` iterations.";

cmroot::f = "The value of the objective function at z0 = `` is very small.  Minimum (or root) found.  Final cost is ``.";

cmroot::g = "The norm of the gradient (``) at z0 = `` is very small.  Extremum (minmum or maximum) found.  Final cost is ``.";

cmroot::step = "The norm of the step size for `` is ``; the search is likely to diverge.  Final cost is ``.";

Options[cmroot] = {
"f" -> ({{0.0}, {{0.0}}, {{{0.0}}}}&),  (* f[c] = {f, Df[, D2f]} *)
"ftol" -> 10.0^-8,

"ls" -> Armijo,
"lsopts" -> {},

Method-> cmc, 
"cm" -> {}, 
"corrector" -> {},
"cmdata" -> {},

(*Scale \[Rule] True,*)
Root -> True,
Print -> False, 
Abort -> True
};

rootmsg = StringTemplate["  cmroot: (``) --- f: `` [\[Phi]: ``] stp: `` info: `` r: ``"];


(* ::Input::Initialization:: *)
cmroot[f_, C_] := Module[{n, F},
n = Length@C;
F = f[C[[1]]];
If[n >= 3, F[[3]] = (C[[2]]\[Transpose] . F[[3]]\[Transpose])\[Transpose] . C[[2]] + F[[2]] . C[[3]];];
If[n >= 2, F[[2]] = F[[2]] . C[[2]];];
F[[1;;n]]
];


(* ::Input::Initialization:: *)
cmroot[Man_, z_, z0_, opts:OptionsPattern[]] := Module[{cm, o, ls, lso,f, F, h, h0, d0, data, d, info, stp, man, nfev, ncmev, r, \[Phi]},
(* continuation parameters *)
cm = OptionValue[Method];
o = OptionValue["cm"];

ls = OptionValue["ls"];
lso = OptionValue["lsopts"];

f = OptionValue["f"];
nfev = 0;
ncmev = 0;

r = OptionValue[Root];
stp = 0;
info = 0;

man = Man[z0];
If[KeyFreeQ[man, "cmroot"], 
(* initialization *)
man = cm[Man, z, z0, o];
F = cmroot[f, man["c"]];
nfev = 1;
\[Phi] = If[r, {0.5 F[[1]] . F[[1]], F[[2]]\[Transpose] . F[[1]]}, F[[All, 1]]]; 
If[\[Phi][[2]] . d0 > 0, d0 = -d0;];,
(* else, is z0 a root? *)
F = man["cmroot", "f"]; (* = {f, df/ds, d^2f/ds^2} *)
 (* should be norm, but crashes *)
If[Abs[F[[1, 1]]] < OptionValue["ftol"] && OptionValue[Abort], 
Message[cmroot::f, z0, F[[1]]];
Throw[$Failed]
];

(* no root, try to reduce cost *)
\[Phi] = man["cmroot", "\[Phi]"];
(* get descent direction (in arclength space) at z0 *)
d0 = step[F];

h = man["h"];
h0 = Norm@d0;

h0 = Min[h, h0];
d0 = h0 Normalize[d0];
(*d0 = If[OptionValue@Scale, h Normalize[step[F]], step[F]];*)


(* perform line search ... need to think about h and d *)
data = {};
While[True,
(* use a merit or objective function *)
\[Phi] = If[r, {0.5 F[[1]] . F[[1]], F[[2]]\[Transpose] . F[[1]]}, F[[All, 1]]];
If[\[Phi][[2]] . d0 > 0, d0 = -d0;];

If[nfev > 0 && Mod[nfev, OptionValue[Print]] === 0, 
Print[rootmsg[nfev, F[[1]], \[Phi][[1]], stp, info, r]];
];

(* compute step *)
data = ls[\[Phi], d0, data, lso];
{d, info, stp} = data[[1;;3]];
If[info != 0, Break[]];

(* project *)
Catch[
(*man = cm[Man, z0 + d / h, z0, o];*)
man["h"] = Norm[d];
d = Normalize[d];
man = cm[<|z0 -> man|>, z0 + d, z0, o];

man["h"] = h; (* restore original h...can this and lines above be avoied? *)

ncmev = ncmev + Lookup[man[[-1]], "nfev", 0];
(* update cost *)
F = cmroot[f, man["c"]];
nfev = nfev + 1;
];
];
];

(* need to update how nfev works b/c of reset each cm *)

(*If[h0 < OptionValue["gtol"], 
Message[cmroot::g, h0, z0, ScientificForm[F0\[LeftDoubleBracket]1\[RightDoubleBracket]]];
Throw[$Failed]
];

If[h0 > OptionValue["dtol"], 
Message[cmroot::step, z0, h0, ScientificForm[F0\[LeftDoubleBracket]1\[RightDoubleBracket]]];
Throw[$Failed]
];
*)
data = <|"f" -> F, "\[Phi]" -> \[Phi], "stp" -> stp, 
"nfev" -> nfev, "ncmev" -> ncmev|>;
Join[man, <|"cmroot" -> data|>]
];


(* ::Input::Initialization:: *)
cmac::h = "The step size is really small: `1` <= `2`.";
cmac::factor = "Couldn't find an acceptable step length.";

cmacmsg = StringTemplate["  cmac (``/``) --- h: `` f: ``\n    max(k: `` (``), d: `` (``), a: `` (``) [``\[Degree] (``\[Degree])]) = ``"];

Options[cmac] = {
"hmin" -> 10.0^-10,
"max" -> 10,

"k" -> 0.025, (* contraction rate of newton's method *)
"d" -> 0.03, (* distance from the prediction z to the curve M(z) = 0 *)
"a" -> 10.0 Degree, (* angle between tangents of prediction and z0 *)
"corrector" -> {}, 
"cmdata" -> {},

Print -> False
};

cmac[Man_, z_, z0_, opts:OptionsPattern[]] := Module[{knom, dnom, anom, o, h, C0, C1, R1, C2, R2, p, d, d1, d2, \[Delta], \[Kappa], \[Alpha], nfev, ncorev, factor, hmin, max, man, k, lim, odata, omand, ftol},
(* Based on Numerical Continuation Methods, Allgower. *)
max = OptionValue["max"];
hmin = OptionValue["hmin"];
knom = OptionValue["k"];
dnom = OptionValue["d"];
anom = OptionValue["a"];
o = OptionValue["corrector"];
odata = OptionValue@"cmdata";
omand = OptionValue[cmdata, odata, "ns"];

nfev = 0;
man = KeyTake[Man, {z0}];
C0 = man[z0, "c"];
p = project[man, z, z0];
k = dim[C0];

If[KeyExistsQ[Man[z0], "cmac"], 
(* compute predictor and step length estimates *)
h = man[z0, "h"] = man[z0, "cmac", "h"];

Do[
factor = 2; (* step length scaler *)
Catch[
d = h p;
(* step 1: prediction step *)
C1 = C0;
C1[[1]] = predictor[C0, d];
R1 = SparseArray /@ augment[C1[[1]], f[C1[[1]]], C1, d];
nfev = nfev + 1;
d1 = step[C1[[1]], R1, o];
(* use normal matrix *)
C1 = mand[C1[[1]], R1[[All, 1;;-k-1]], C0[[2]], omand];
(* step 2: corrector step *)
C2 = C1[[1]] + d1;
R2 = SparseArray /@ augment[C2, f[C2], C1, d, R1];
nfev = nfev + 1;
R2[[2;;]] = R1[[2;;]];
d2 = step[C2, R2, o]; (* use augmented matrix *)
(* step 3: get estimates *)
\[Delta] = Norm[d1];
\[Kappa] = Norm[d2]/\[Delta];
\[Alpha] = Re@ArcCos[(p . C0[[2]]\[Transpose]) . (C1[[2]] . p)]; (* take k down to 1 in dir. of p *)

(* correction *)
(*factor = 2;
Catch[*)
(* should modify to take advantage of prev. computations *)
(* should simplify prediction to include call to corrector *)
{C2, R2, ncorev} = corrector[C1[[1]], d, C0, "f+" -> augment, o];
R2 = R2[[All, 1;;-k-1]];
nfev = nfev + ncorev;

factor = Max[Sqrt[\[Kappa]/knom], Sqrt[\[Delta]/dnom], \[Alpha]/anom];
factor = Max[Min[factor, 2], 0.5];
];
h = h / factor;

If[Mod[i, OptionValue[Print]] === 0, 
lim = {Sqrt[\[Kappa]/knom], Sqrt[\[Delta]/dnom], \[Alpha]/anom};
lim = AssociationThread[{"k", "d", "a"} -> lim];
lim = First@MaximalBy[Keys@lim, lim];
Print[
cmacmsg[i, max, Sequence@@(NumberForm[#, {3, 3}]& /@ {h, factor, \[Kappa], knom, \[Delta], dnom, \[Alpha], anom, \[Alpha] / Degree, anom / Degree}), lim]];
];

(*If[factor < 2, Break[]];*)
ftol = OptionValue[corrector, o, "ftol"];
If[factor < 2 && Norm[R2[[1]]] <= ftol, Break[]];

If[Abs[h] < hmin, 
Message[cmac::h,h, hmin]; 
Throw[$Failed]
];,
{i, max}
];

If[factor >= 2, 
Message[cmac::factor]; 
Throw@$Failed
];, 
(* else --- initialization *)
h = man[z0, "h"];
d = h p;
C2 = predictor[C0, d];
{C2, R2, ncorev} = corrector[C2, d, C0, "f+" -> augment, o];
R2 = R2[[All, 1;;-k-1]];
nfev = nfev + ncorev;
];

(* return info *)
o = <|"cmac" -> <|"h" -> h, "nfev" -> nfev|>|>;
cmdata[Man, z, z0, C2, R2, o, odata]
];

StepPlot[Man_, opts: OptionsPattern[]] := ListPlot[Values@KeySort@Select[Man, # =!= $Failed && KeyExistsQ[#, "cmac"]&][[All, "cmac", "h"]], opts]


(* ::Input::Initialization:: *)
Options[cmnat] = {"i" -> {-1}, "h" -> (None&), "corrector" -> {},  "cmdata" -> {},  Print -> False};

cmnat[Man_, z_, z0_, OptionsPattern[]] := Module[{h, C0, k, d, c, o, R, A, nfev, a, i},
(* get step *)
h = OptionValue["h"][z];
If[!NumericQ[h] && !VectorQ[h, NumericQ], h = Man[z0, "h"]];

(* current point *)
C0 = Man[z0, "c"];
k = dim[C0];

(* prediction *)
d = h project[Man, z, z0];
c = C0[[1]];

i = OptionValue["i"];
c[[i]] = Man[z0, "c"][[1, i]] + d;

(* augmentation *)
a = SparseArray[MapIndexed[{#2[[1]], #1} -> 1.0&, i], {Length@i, Length@c}];
a = With[{g = a, ci = c[[i]]}, MapThread[Join, {#2, {#1[[i]] - ci, g}}]&];

(* correction *)
o = OptionValue["corrector"];
{c, R, nfev} = corrector[c, h, C0, "f+" -> a, o];

(* split augmented root *)
{R, A} = {R[[All, 1;;-k-1]], R[[All, -k;;-1]]};

(* return info *)
o = OptionValue@"cmdata";
A = <|"cmnat" -> <|"nfev" -> nfev, "h" -> h|>|>;
cmdata[Man, z, z0, c, R, A, o]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
