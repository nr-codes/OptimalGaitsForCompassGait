(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*
DifferentiateFunction.nb: A list of routines that will differentiate various NLink functions to C code.
Copyright (C) 2016 Nelson Rosa Jr.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. This program is distributed in the 
hope that it will be useful, but WITHOUT ANY WARRANTY; without even the 
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details. You should have 
received a copy of the GNU General Public License along with this program.
If not, see <http://www.gnu.org/licenses/>.
*)


(* ::Input::Initialization:: *)
BeginPackage["Derivatives`"]

DerivativeOrder::usage = "";
CreateSymbolString::usage = "";
CreateSymbol::usage = "";
TransformExpression::usage = "";
BlockExpression::usage = "";
DifferentiateFunction::usage = "";
MergeFunctions::usage = "";
CheckSetStatements::usage = "";

Begin["`Private`"]


(* ::Input::Initialization:: *)
SetAttributes[\[FormalP], HoldAll];


(* ::Input::Initialization:: *)
SetAttributes[DerivativeOrder, HoldFirst];

DerivativeOrder[x_] := Module[{s, n},
s = ToString@Unevaluated@x;
s = Last@StringSplit[s, "`"]; (* remove context path *)
n = Max[StringPosition[s, (StartOfString~~"d"..)~~LetterCharacter]];
If[n > 0, n - 1, 0]
];


(* ::Input::Initialization:: *)
(* enforce derivative naming convention *)
CreateSymbolString[x_String, d_Integer:0] := If[d > 0, StringInsert[x, StringRepeat["d", d], Last@Last@StringPosition["`" <> x, "`"]], x];

CreateSymbolString[x_Symbol, d_Integer:0] := CreateSymbolString[ToString@Unevaluated@x, d];

CreateSymbolString[Derivative[d_][x_], e_Integer:0] :=  CreateSymbolString[Unevaluated@x, d+e];


(* ::Input::Initialization:: *)
SetAttributes[CreateSymbol, HoldFirst];

(* default *)
CreateSymbol[x_] := CreateSymbol[x,0, Hold];

(* symbols *)
CreateSymbol[x_Symbol, d_Integer:0] := If[d  > 0, Symbol[CreateSymbolString[Unevaluated@x, d]], x];

(* functions *)
CreateSymbol[\[FormalP][x_], d_Integer:0] := CreateSymbol[x, d];

CreateSymbol[HoldPattern@Transpose[x_, y___], d_Integer:0] := Transpose[CreateSymbol[x, d], y];

CreateSymbol[HoldPattern@Part[x_, y___], d_Integer:0] := Part[CreateSymbol[x, d], y] //. HoldPattern[Part[Part[a_, b__], c__]] :> Part[a, b, c];

CreateSymbol[f_[x___], d_Integer:0] :=  CreateSymbol[f, d][CreateArguments[{x}, d]];

CreateSymbol[f_Symbol[x___], d_Integer:0] :=  Symbol[CreateSymbolString[Unevaluated@f, d]][CreateArguments[{x}, d]];

(* derivatives *)
CreateSymbol[Derivative[d_][x_], e_Integer:0] :=  CreateSymbol[x, d+e];

CreateSymbol[Derivative[d_][f_[x___]], e_Integer:0] :=  CreateSymbol[f[x], d+e];

CreateSymbol[Derivative[d_][f_][x___], e_Integer:0] :=  CreateSymbol[f[x], d+e];

(* does not work with e > 0 *)
(* solution is to precall or postcall CreateSymbol with e *)
(* depending on what it means to diff by e only *)
(*CreateSymbol[Derivative[d__][x_], e_Integer:0] :=  Module[{n, i},
n =Plus[d];
i = List@CreateIndices[Length@{d}];
CreateSymbol[x, n] /. Thread[Take[i, n] \[Rule] Pick[i, {d}, 1]]
];*)


(* ::Input::Initialization:: *)
(* blocks functions and variables and allows for post-processing *)
CreateSymbol[x_, d_Integer, fcn_] := Module[{s, f, n, v, dv, b, w},
w = {Part, Transpose};
s = \[FormalP] /@ w;

w = Function[e, ToString@Unevaluated[e], {HoldAll}];
v = ExtractVariables[x, w];

w = Function[e, ToString@Unevaluated[e], {HoldAll}];
f = ExtractSubfunctions[x, w];

(* find max derivative *)
w = Function[e, \[FormalP][e] , {HoldAll}];
n = ExtractDerivatives[x, w];
n = Max[Cases[n, Derivative[n__][___] :> Plus[n], Infinity], 0];

(* create symbols *)
f = Lookup[f, True, {}];
v = Flatten@Values@v;

w = Function[e, CreateSymbolString[e, 1], {Listable, HoldAll}];
v = DeleteDuplicates@Flatten@NestList[w, Join[f, v], d + n];

v = ToExpression[v, InputForm, \[FormalP]];
v = Join[s, v];

(* apply fcn *)
f = Hold[Block[b, fcn@Evaluate@CreateSymbol[x, d]]];
ReleaseHold[f /. b -> v /. \[FormalP][e_] :> e]
];


(* ::Input::Initialization:: *)
SetAttributes[RemoveSymbol, {HoldFirst, Listable}];

RemoveSymbol[var_Symbol] := Module[{v},
v = ToString@Unevaluated[var];
RemoveSymbol[Evaluate@v]
];

RemoveSymbol[var_String] := Module[{n, c, v},
(* separate context from name *)
v = ctxt:(___ ~~ "`")... ~~ x:(_).. :> {ctxt, x};
{c, n} = First@StringCases[var, v];

(* get all variables that end in var *)
v = c <> "d*" <> n;
v = Names@v;

(* search for variables with derivative naming scheme *)
v = StringCases[v, StartOfString ~~ c ~~ "d".. ~~ n];
v = Flatten@v;

(* remove derivative names *)
Remove /@ v;

(* return symbols removed as list of strings *)
v
];


(* ::Input::Initialization:: *)
CreateIndices[d_Integer] := Sequence@@Table[Symbol["\[FormalD]" <> ToString@i], {i, d}];

SetAttributes[CreateArguments, HoldFirst];
CreateArguments[x_List, d_Integer:0] := Sequence@@Flatten@Function[e, Table[CreateSymbol[e, j], {j, 0, d}], {Listable, HoldFirst}][x];

SetAttributes[CreateArgumentsString, HoldFirst];
CreateArgumentsString[x_List, d_Integer:0] := Sequence@@Flatten@Function[e, Table[CreateSymbolString[e, j], {j, 0, d}], {Listable, HoldFirst}][x];

SetAttributes[CreateFunctionArguments, HoldFirst];
CreateFunctionArguments[f_Symbol[x___], d_Integer:0, fcn_:Identity] := Module[{F, a, s}, 
s = ToString@Unevaluated@#&;
F = CreateSymbol[f[], d, s];
a = Thread@\[FormalP][{x}];
a = Flatten@Table[CreateSymbol[Evaluate@i, j, s], {i, a}, {j, 0, d}];
a = StringRiffle[a, ", "];
F = StringInsert[F, a, -2];
ToExpression[F, InputForm, fcn]
];

SetAttributes[CreateDerivative, HoldFirst]
CreateDerivative[x_, e_Integer: 0, d_Integer:0] := Which[
d == 0, x,
e < 2^d,
With[
{f = Derivative[Sequence@@Reverse@PadLeft[IntegerDigits[e, 2], d]]},
CreateSymbol[f[x], 0]
],
True,
Throw[$Failed]
];


(* ::Input::Initialization:: *)
DifferentiateFunctionArguments[fcn_, n_] := Module[{m, a, f, g, h},
(* get function name *)
f = Cases[fcn, HoldPattern[_[f_[___]] :> _] :> HoldPattern[f[___]]];

(* get function arguments *)
m = Position[fcn, First@f];
a = Extract[fcn, m, Hold];

a = Level[a, {-1}, Hold];
a = List@ReleaseHold[ToString /@ Unevaluated /@ a];

(* get derivatives of function arguments *)
g = Function[e, CreateSymbolString[e, 1], {Listable, HoldAll}];
a = Flatten@Transpose@NestList[g, a, n];
a = # <> "_"& /@ a;
a = ToExpression[#, InputForm, \[FormalP]]& /@ a;

(* get name derivative of function *)
f = f[[1,1,0]];
f = ToExpression[CreateSymbolString[f, n], InputForm, \[FormalP]];

(* apply changes *)
a = ReplacePart[fcn, m -> h[Sequence@@a]];
a /. h  -> f /. \[FormalP][x_] :> x
];


(* ::Input::Initialization:: *)
DifferentiateLocalArguments[fcn_, n_] := Module[{v, a, f},
(* globally inspect function and extract symbols *)
v = Function[x, ToString@Unevaluated@x, {Listable, HoldFirst}];
a = Cases[fcn, HoldPattern[Module[x_, y_]] :> {v[x], ExtractVariables[y, v]}, Infinity];

(* separate variables and indices *)
If[Length@a > 0,
{a, v} = First@a;
a = Thread@a; (* what does this do? *)
v = GroupBy[a, MemberQ[v[True], #]&];
a = Lookup[v, True, {}];
v = Lookup[v, False, {}];
];

(* differentiate variables *)
f = Function[e, CreateSymbolString[e, 1], {Listable, HoldAll}];
a = Flatten@Transpose@NestList[f, a, n];
a = ToExpression[#, InputForm, \[FormalP]]& /@ Join[a, v];

(* modify function *)
f = fcn /. HoldPattern[Module[_, y_]] :> Module[a, y];
f /. HoldPattern[a] -> a  /. \[FormalP][x_] :> x
];


(* ::Input::Initialization:: *)
SetAttributes[ExtractSubfunctions, HoldFirst];

ExtractSubfunctions[expr_, fcn_:Identity] := Module[{h, f},
(* apply fcn and convert symbol to string *)
h = Function[x, {fcn@x, ToString@Unevaluated@x}, {Listable, HoldAll}];

(* extract all functions *)
f = Cases[Hold@expr, f_Symbol[___] :> h@f, {1, -2}];
f = DeleteDuplicates[f];

(* group System functions under False *)
h = StringFreeQ[Context[Evaluate@Last@#], StartOfString~~"System`"]&;
(*GroupBy[f, h]\[LeftDoubleBracket]All, All, 1\[RightDoubleBracket]*)
(* make Part safe *)
Map[First, GroupBy[f, h], {2}]
];


(* ::Input::Initialization:: *)
SetAttributes[ExtractDerivatives, HoldFirst];

ExtractDerivatives[expr_, fcn_:Identity] := Module[{h, e, f},
h = Function[x, fcn@x, {Listable, HoldAll}];
e = Hold@expr;
f = Position[e, HoldPattern[Derivative[__][_]]];
f = Extract[e, f, h];
f = DeleteDuplicates[f];
<| True-> f |>
];


(* ::Input::Initialization:: *)
SetAttributes[ExtractVariables, HoldFirst];

ExtractVariables[expr_, fcn_:Identity] := Module[{h, v, i},
(* apply fcn and convert symbol to string *)
h = Function[x, {fcn@x, ToString@Unevaluated@x}, {Listable, HoldAll}];

(* get all leaves of an expression *)
v = Cases[Hold@expr, Except[Null, x_Symbol] :> h@x, {-1}];
v = DeleteDuplicates[v];

(* extract all indices *)
i = Cases[Hold@expr, HoldPattern[x_[[y__]]] :> Hold[{y}], Infinity];
i = Cases[i, x_Symbol :> h@x, {-1}];
i = DeleteDuplicates@Partition[Flatten@i, 2];

(* group indexing variables under False *)
h = FreeQ[i[[All, 2]], Last@#]&;

(*GroupBy[v, h]\[LeftDoubleBracket]All, All, 1\[RightDoubleBracket]*)
(* make Part safe *)
Map[First, GroupBy[v, h], {2}]
];


(* ::Input::Initialization:: *)
SetAttributes[TransformExpression, HoldFirst];

TransformExpression[expr_] := Module[{s, f, v, x, w},
(* wrap hold variable \[FormalP] around variables and functions *)
w = {Part, Transpose};
s = HoldPattern[Pattern[x,Blank[#]]] :>  \[FormalP][x][\[FormalR]]& /@ w;

w = Function[x, HoldPattern[x] :>  \[FormalP][x][\[FormalR]], {HoldAll}];
v = ExtractVariables[expr, w];

w = Function[h, HoldPattern[x_h] :>  \[FormalP][x][\[FormalR]], {HoldAll}];
f = ExtractSubfunctions[expr, w];

f = Lookup[f, True, {}];
v = Lookup[v, True, {}];

ReleaseHold[Hold[expr] /. Join[s, f, v]]
];

RestoreExpression[expr_] := expr /. HoldPattern[f_[\[FormalR]]] :> CreateSymbol[f];

DifferentiateExpression[expr_, x_, n_] := Module[{v, f, e},
If[x === \[FormalR],
(* expression has prespecified what to differentiate *)
v = expr,
(* o.w., differentiate with respect to variables in x *)
f = Function[e, e -> e[\[FormalR]], {Listable}];
v = expr /. Flatten[f[x]]
];

(*Table[D[v, {\[FormalR], e}], {e, 0, n}]*)
If[VectorQ[n],
D[v, {\[FormalR], First@n}],
NestList[D[#, \[FormalR]]&, v, n]
]
];


(* ::Input::Initialization:: *)
SetAttributes[{WrapExpression, BlockExpression}, HoldAll];

WrapExpression[expr_, fcn_:Hold] := Module[{v, f, h},
(* returns expr with all symbols wrapped in fcn *)
h = Function[x, HoldPattern[x]:> fcn[x], HoldAll];
v = ExtractVariables[expr, h];
f = ExtractSubfunctions[expr, h];
h = Merge[{v, f}, Flatten];
fcn[expr] /. h[True]
];

BlockExpression[b_List, expr_, e_List:{}] := Module[{v, f, h},
(* get all variables and functions *)
h = Function[x, \[FormalP][x], HoldAll];
v = ExtractVariables[expr, h];
f = ExtractSubfunctions[expr, h];
h = Merge[{v, f}, Flatten];
(* place in block environment *)
f = Function[x, \[FormalP][x], {Listable, HoldAll}];
h = Join[f@b, Lookup[h, True, {}], Lookup[v, False, {}]];
(* except those symbols in e *)
f = Complement[h,f@e];
v = Hold[Block[v, expr]] /. HoldPattern[v] -> f;
(* evaluate expr *)
First[v /. \[FormalP][x_] :> x]
];


(* ::Input::Initialization:: *)
TransformExpression[HoldPattern@Set[x_, y_]] := {TransformExpression[x], TransformExpression[y]};

FlattenCompoundExpressions[e_] := e //. HoldPattern[CompoundExpression[x___, CompoundExpression[y__], z___]] :> CompoundExpression[x, y, z] //. HoldPattern[CompoundExpression[x__, Null, y__]] :> CompoundExpression[x, y]


(* ::Input::Initialization:: *)
DifferentiateSetStatements[fcn_, n_] := Module[{v, m, d},
d = Lookup[ExtractVariables[fcn, \[FormalP]], False, {}];

(* extract and transform all set statements, adds \[FormalR] to symbols *)
m = Position[fcn, HoldPattern[Set[_, _]]];
v = Extract[fcn, m, TransformExpression];

(* remove statements x = y, where x is an index or x = IgnoreCase *)
If[d =!= {},
d = Append[Through[d[\[FormalR]]], IgnoreCase];
d = Select[Range@Length@m, FreeQ[d, v[[#, 1]]]&];
m = m[[d]];
v = v[[d]];
];

(* drop statements with zeros as results *)
(*v = Select[#, !PossibleZeroQ[Last@#]&]& /@ v;*)

(* differentiate statements *)
v = DifferentiateExpression[v, \[FormalR], n];
v = RestoreExpression[v\[Transpose]];

(* restore set statement *)
v = Apply[\[FormalP][#1 = #2]&, v, {2}] /. Hold[x_] :> x;
(* add derivatives to extracted statements *)
v = # /. {x__} :> \[FormalP][CompoundExpression[x]]& /@ v;
v = ReplacePart[fcn, Thread[m -> v]]  //. \[FormalP][x_] :> x;

(* flatten the excessive compound expressions *) 
FlattenCompoundExpressions[v]
];


(* ::Input::Initialization:: *)
CheckSetStatements::ss = "Assignment with variable appearing in lhs and rhs.  Potential bug in computing derivative (e.g., if multiplication or dot products are involved).  See note in DifferentiateFunction.nb.  Check input function(s).";

CheckSetStatements[fcn_] := Module[{v, m, d},
d = Lookup[ExtractVariables[fcn, \[FormalP]], False, {}];

(* extract and transform all set statements, adds \[FormalR] to symbols *)
m = Position[fcn, HoldPattern[Set[_, _]]];
v = Extract[fcn, m, TransformExpression];

(* remove statements x = y, where x is an index or x = IgnoreCase *)
If[d =!= {},
d = Append[Through[d[\[FormalR]]], IgnoreCase];
d = Select[Range@Length@m, FreeQ[d, v[[#, 1]]]&];
m = m[[d]];
v = v[[d]];
];

d = Outer|Times|Dot|Power;
d = Count[#[[2]], d[___, #[[1]], ___], -2]& /@ v;
If[Total[d] > 0,
Message[CheckSetStatements::ss];
m = Pick[m, d, i_ /; i > 0];
v = Pick[v, d, i_ /; i > 0];
v = MapThread[Hold[#1 = #2]&, v\[Transpose]] /. \[FormalP][x_][\[FormalR]] :> x;
AssociationThread[m -> v],
(* else *)
<||>
]
];


(* ::Input::Initialization:: *)
SetAttributes[MergeFunctions, HoldRest];
MergeFunctions[fcns_, F_, lcls_:{}, n_:0] := Module[{f, p, e, g, a, b},
f = DownValues /@ fcns;
e = Cases[f, HoldPattern[Module[x_, y_]] :> {Hold[x], Hold[y]}, Infinity];

(* wrap Hold around each arg *)
a = Prepend[e[[All, 1]], Hold[lcls]];
a = Join@@(Thread /@ a);
a = DeleteDuplicates[a];

(* combine separate expression into one *)
b = Join@@e[[All, 2]] /. Hold[x__] :> Hold[CompoundExpression[x]];
b = FlattenCompoundExpressions[b];

g = {HoldPattern[a] -> a, HoldPattern[b] -> b};

f = Head[F];
ReleaseHold[
Hold@Block[{"F"},
DownValues["F"] = {HoldPattern[F]:>Module[a, b]} /. g /. Hold[x_] :> x;
DifferentiateFunction["F", n]
] /. "F" -> f
]
];


(* ::Input::Initialization:: *)
DifferentiateFunction[fcn_, n_] := Module[{f},
f = DownValues@fcn;
f = DifferentiateFunctionArguments[f, n];
f = DifferentiateLocalArguments[f, n];
DifferentiateSetStatements[f, n]
];


(* ::Input::Initialization:: *)
End[]
EndPackage[]
